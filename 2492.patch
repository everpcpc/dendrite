From 1d6501ae3086a08152a0cbaf60a765d5e84bd09b Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 27 Sep 2021 11:36:02 +0200
Subject: [PATCH 01/35] Ensure every HTTP server context has a timeout.

Code that uses http.NewRequestWithContext will see the same deadline.
---
 setup/base/base.go | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/setup/base/base.go b/setup/base/base.go
index 5cbd7da9c3..a37902f800 100644
--- a/setup/base/base.go
+++ b/setup/base/base.go
@@ -92,6 +92,7 @@ type BaseDendrite struct {
 const NoListener = ""
 
 const HTTPServerTimeout = time.Minute * 5
+const HTTPServerRequestTimeout = HTTPServerTimeout
 const HTTPClientTimeout = time.Second * 30
 
 type BaseDendriteOptions int
@@ -384,6 +385,7 @@ func (b *BaseDendrite) SetupAndServeHTTP(
 	externalAddr, _ := externalHTTPAddr.Address()
 
 	externalRouter := mux.NewRouter().SkipClean(true).UseEncodedPath()
+	externalRouter.Use(timeoutMiddleware)
 	internalRouter := externalRouter
 
 	externalServ := &http.Server{
@@ -521,6 +523,15 @@ func (b *BaseDendrite) SetupAndServeHTTP(
 	logrus.Infof("Stopped HTTP listeners")
 }
 
+// timeoutMiddleware is a Gorilla middleware that adds a timeout to all request contexts.
+func timeoutMiddleware(next http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		ctx, cancel := context.WithTimeout(r.Context(), HTTPServerRequestTimeout)
+		defer cancel()
+		next.ServeHTTP(w, r.WithContext(ctx))
+	})
+}
+
 func (b *BaseDendrite) WaitForShutdown() {
 	sigs := make(chan os.Signal, 1)
 	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

From 43989aa01708e084de7c2e657853cfcafb57191e Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Sun, 26 Sep 2021 12:16:05 +0200
Subject: [PATCH 02/35] Support for m.login.sso.

This is forked from @anandv96's #1374. Closes #1297.
---
 clientapi/auth/auth.go                 |   1 +
 clientapi/auth/authtypes/logintypes.go |   1 +
 clientapi/auth/sso/github.go           |  37 ++++
 clientapi/auth/sso/oidc_base.go        | 262 +++++++++++++++++++++++
 clientapi/auth/sso/sso.go              |  57 +++++
 clientapi/routing/login.go             |  62 +++++-
 clientapi/routing/routing.go           |  19 ++
 clientapi/routing/sso.go               | 283 +++++++++++++++++++++++++
 clientapi/userutil/identifier.go       | 153 +++++++++++++
 clientapi/userutil/identifier_test.go  |  75 +++++++
 setup/config/config_clientapi.go       | 123 +++++++++++
 11 files changed, 1062 insertions(+), 11 deletions(-)
 create mode 100644 clientapi/auth/sso/github.go
 create mode 100644 clientapi/auth/sso/oidc_base.go
 create mode 100644 clientapi/auth/sso/sso.go
 create mode 100644 clientapi/routing/sso.go
 create mode 100644 clientapi/userutil/identifier.go
 create mode 100644 clientapi/userutil/identifier_test.go

diff --git a/clientapi/auth/auth.go b/clientapi/auth/auth.go
index 93345f4b9d..fb6975218a 100644
--- a/clientapi/auth/auth.go
+++ b/clientapi/auth/auth.go
@@ -43,6 +43,7 @@ type AccountDatabase interface {
 	// Look up the account matching the given localpart.
 	GetAccountByLocalpart(ctx context.Context, localpart string) (*api.Account, error)
 	GetAccountByPassword(ctx context.Context, localpart, password string) (*api.Account, error)
+	GetLocalpartForThreePID(ctx context.Context, address, medium string) (string, error)
 }
 
 // VerifyUserFromRequest authenticates the HTTP request,
diff --git a/clientapi/auth/authtypes/logintypes.go b/clientapi/auth/authtypes/logintypes.go
index f01e48f806..2b19b355c9 100644
--- a/clientapi/auth/authtypes/logintypes.go
+++ b/clientapi/auth/authtypes/logintypes.go
@@ -10,5 +10,6 @@ const (
 	LoginTypeSharedSecret       = "org.matrix.login.shared_secret"
 	LoginTypeRecaptcha          = "m.login.recaptcha"
 	LoginTypeApplicationService = "m.login.application_service"
+	LoginTypeSSO                = "m.login.sso"
 	LoginTypeToken              = "m.login.token"
 )
diff --git a/clientapi/auth/sso/github.go b/clientapi/auth/sso/github.go
new file mode 100644
index 0000000000..55f5417b66
--- /dev/null
+++ b/clientapi/auth/sso/github.go
@@ -0,0 +1,37 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sso
+
+import (
+	"github.com/matrix-org/dendrite/setup/config"
+)
+
+// GitHubIdentityProvider is a GitHub-flavored identity provider.
+var GitHubIdentityProvider IdentityProvider = githubIdentityProvider{
+	baseOIDCIdentityProvider: &baseOIDCIdentityProvider{
+		AuthURL:                     mustParseURLTemplate("https://github.com/login/oauth/authorize?scope=user:email"),
+		AccessTokenURL:              mustParseURLTemplate("https://github.com/login/oauth/access_token"),
+		UserInfoURL:                 mustParseURLTemplate("https://api.github.com/user"),
+		UserInfoAccept:              "application/vnd.github.v3+json",
+		UserInfoEmailPath:           "email",
+		UserInfoSuggestedUserIDPath: "login",
+	},
+}
+
+type githubIdentityProvider struct {
+	*baseOIDCIdentityProvider
+}
+
+func (githubIdentityProvider) DefaultBrand() string { return config.SSOBrandGitHub }
diff --git a/clientapi/auth/sso/oidc_base.go b/clientapi/auth/sso/oidc_base.go
new file mode 100644
index 0000000000..20cd7b2cbb
--- /dev/null
+++ b/clientapi/auth/sso/oidc_base.go
@@ -0,0 +1,262 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sso
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"io/ioutil"
+	"mime"
+	"net/http"
+	"net/url"
+	"strings"
+	"text/template"
+
+	"github.com/matrix-org/dendrite/clientapi/jsonerror"
+	"github.com/matrix-org/dendrite/clientapi/userutil"
+	"github.com/tidwall/gjson"
+)
+
+type baseOIDCIdentityProvider struct {
+	AuthURL                     *urlTemplate
+	AccessTokenURL              *urlTemplate
+	UserInfoURL                 *urlTemplate
+	UserInfoAccept              string
+	UserInfoEmailPath           string
+	UserInfoSuggestedUserIDPath string
+}
+
+func (p *baseOIDCIdentityProvider) AuthorizationURL(ctx context.Context, req *IdentityProviderRequest) (string, error) {
+	u, err := p.AuthURL.Execute(map[string]interface{}{
+		"Config":      req.System,
+		"State":       req.DendriteNonce,
+		"RedirectURI": req.CallbackURL,
+	}, url.Values{
+		"client_id":     []string{req.System.OIDC.ClientID},
+		"response_type": []string{"code"},
+		"redirect_uri":  []string{req.CallbackURL},
+		"state":         []string{req.DendriteNonce},
+	})
+	if err != nil {
+		return "", err
+	}
+	return u.String(), nil
+}
+
+func (p *baseOIDCIdentityProvider) ProcessCallback(ctx context.Context, req *IdentityProviderRequest, values url.Values) (*CallbackResult, error) {
+	state := values.Get("state")
+	if state == "" {
+		return nil, jsonerror.MissingArgument("state parameter missing")
+	}
+	if state != req.DendriteNonce {
+		return nil, jsonerror.InvalidArgumentValue("state parameter not matching nonce")
+	}
+
+	if error := values.Get("error"); error != "" {
+		if euri := values.Get("error_uri"); euri != "" {
+			return &CallbackResult{RedirectURL: euri}, nil
+		}
+
+		desc := values.Get("error_description")
+		if desc == "" {
+			desc = error
+		}
+		switch error {
+		case "unauthorized_client", "access_denied":
+			return nil, jsonerror.Forbidden("SSO said no: " + desc)
+		default:
+			return nil, fmt.Errorf("SSO failed: %v", error)
+		}
+	}
+
+	code := values.Get("code")
+	if code == "" {
+		return nil, jsonerror.MissingArgument("code parameter missing")
+	}
+
+	oidcAccessToken, err := p.getOIDCAccessToken(ctx, req, code)
+	if err != nil {
+		return nil, err
+	}
+
+	id, userID, err := p.getUserInfo(ctx, req, oidcAccessToken)
+	if err != nil {
+		return nil, err
+	}
+
+	return &CallbackResult{Identifier: id, SuggestedUserID: userID}, nil
+}
+
+func (p *baseOIDCIdentityProvider) getOIDCAccessToken(ctx context.Context, req *IdentityProviderRequest, code string) (string, error) {
+	u, err := p.AccessTokenURL.Execute(nil, nil)
+	if err != nil {
+		return "", err
+	}
+
+	body := url.Values{
+		"grant_type":   []string{"authorization_code"},
+		"code":         []string{code},
+		"redirect_uri": []string{req.CallbackURL},
+		"client_id":    []string{req.System.OIDC.ClientID},
+	}
+
+	hreq, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), strings.NewReader(body.Encode()))
+	if err != nil {
+		return "", err
+	}
+	hreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	hreq.Header.Set("Accept", "application/x-www-form-urlencoded")
+
+	hresp, err := http.DefaultClient.Do(hreq)
+	if err != nil {
+		return "", err
+	}
+	defer hresp.Body.Close()
+
+	ctype, _, err := mime.ParseMediaType(hresp.Header.Get("Content-Type"))
+	if err != nil {
+		return "", err
+	}
+	if ctype != "application/json" {
+		return "", fmt.Errorf("expected URL encoded response, got content type %q", ctype)
+	}
+
+	var resp struct {
+		TokenType   string `json:"token_type"`
+		AccessToken string `json:"access_token"`
+
+		Error            string `json:"error"`
+		ErrorDescription string `json:"error_description"`
+		ErrorURI         string `json:"error_uri"`
+	}
+	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
+		return "", err
+	}
+
+	if resp.Error != "" {
+		desc := resp.ErrorDescription
+		if desc == "" {
+			desc = resp.Error
+		}
+		return "", fmt.Errorf("failed to retrieve OIDC access token: %s", desc)
+	}
+
+	if strings.ToLower(resp.TokenType) != "bearer" {
+		return "", fmt.Errorf("expected bearer token, got type %q", resp.TokenType)
+	}
+
+	return resp.AccessToken, nil
+}
+
+func (p *baseOIDCIdentityProvider) getUserInfo(ctx context.Context, req *IdentityProviderRequest, oidcAccessToken string) (*userutil.ThirdPartyIdentifier, string, error) {
+	u, err := p.UserInfoURL.Execute(map[string]interface{}{
+		"Config": req.System,
+	}, nil)
+	if err != nil {
+		return nil, "", err
+	}
+
+	hreq, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
+	if err != nil {
+		return nil, "", err
+	}
+	hreq.Header.Set("Authorization", "token "+oidcAccessToken)
+	hreq.Header.Set("Accept", p.UserInfoAccept)
+
+	hresp, err := http.DefaultClient.Do(hreq)
+	if err != nil {
+		return nil, "", err
+	}
+	defer hresp.Body.Close()
+
+	ctype, _, err := mime.ParseMediaType(hresp.Header.Get("Content-Type"))
+	if err != nil {
+		return nil, "", err
+	}
+
+	var email string
+	var suggestedUserID string
+	switch ctype {
+	case "application/json":
+		body, err := ioutil.ReadAll(hresp.Body)
+		if err != nil {
+			return nil, "", err
+		}
+
+		emailRes := gjson.GetBytes(body, p.UserInfoEmailPath)
+		if !emailRes.Exists() {
+			return nil, "", fmt.Errorf("no email in user info response body")
+		}
+		email = emailRes.String()
+
+		// This is optional.
+		userIDRes := gjson.GetBytes(body, p.UserInfoSuggestedUserIDPath)
+		suggestedUserID = userIDRes.String()
+
+	default:
+		return nil, "", fmt.Errorf("got unknown content type %q for user info", ctype)
+	}
+
+	if email == "" {
+		return nil, "", fmt.Errorf("no email address in user info")
+	}
+
+	return &userutil.ThirdPartyIdentifier{Medium: "email", Address: email}, suggestedUserID, nil
+}
+
+type urlTemplate struct {
+	base *template.Template
+}
+
+func parseURLTemplate(s string) (*urlTemplate, error) {
+	t, err := template.New("").Parse(s)
+	if err != nil {
+		return nil, err
+	}
+	return &urlTemplate{base: t}, nil
+}
+
+func mustParseURLTemplate(s string) *urlTemplate {
+	t, err := parseURLTemplate(s)
+	if err != nil {
+		panic(err)
+	}
+	return t
+}
+
+func (t *urlTemplate) Execute(params interface{}, defaultQuery url.Values) (*url.URL, error) {
+	var sb strings.Builder
+	err := t.base.Execute(&sb, params)
+	if err != nil {
+		return nil, err
+	}
+
+	u, err := url.Parse(sb.String())
+	if err != nil {
+		return nil, err
+	}
+
+	if defaultQuery != nil {
+		q := u.Query()
+		for k, vs := range defaultQuery {
+			if q.Get(k) == "" {
+				q[k] = vs
+			}
+		}
+		u.RawQuery = q.Encode()
+	}
+	return u, nil
+}
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
new file mode 100644
index 0000000000..653863d8fc
--- /dev/null
+++ b/clientapi/auth/sso/sso.go
@@ -0,0 +1,57 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sso
+
+import (
+	"context"
+	"net/url"
+
+	"github.com/matrix-org/dendrite/clientapi/userutil"
+	"github.com/matrix-org/dendrite/setup/config"
+)
+
+type IdentityProvider interface {
+	DefaultBrand() string
+
+	AuthorizationURL(context.Context, *IdentityProviderRequest) (string, error)
+	ProcessCallback(context.Context, *IdentityProviderRequest, url.Values) (*CallbackResult, error)
+}
+
+type IdentityProviderRequest struct {
+	System        *config.IdentityProvider
+	CallbackURL   string
+	DendriteNonce string
+}
+
+type CallbackResult struct {
+	RedirectURL     string
+	Identifier      *userutil.ThirdPartyIdentifier
+	SuggestedUserID string
+}
+
+type IdentityProviderType string
+
+const (
+	TypeGitHub IdentityProviderType = config.SSOBrandGitHub
+)
+
+func GetIdentityProvider(t IdentityProviderType) IdentityProvider {
+	switch t {
+	case TypeGitHub:
+		return GitHubIdentityProvider
+	default:
+		return nil
+	}
+}
diff --git a/clientapi/routing/login.go b/clientapi/routing/login.go
index 6017b58404..97b3979289 100644
--- a/clientapi/routing/login.go
+++ b/clientapi/routing/login.go
@@ -19,6 +19,8 @@ import (
 	"net/http"
 
 	"github.com/matrix-org/dendrite/clientapi/auth"
+	"github.com/matrix-org/dendrite/clientapi/auth/authtypes"
+	"github.com/matrix-org/dendrite/clientapi/auth/sso"
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/clientapi/userutil"
 	"github.com/matrix-org/dendrite/setup/config"
@@ -35,20 +37,54 @@ type loginResponse struct {
 }
 
 type flows struct {
-	Flows []flow `json:"flows"`
+	Flows []stage `json:"flows"`
 }
 
-type flow struct {
-	Type string `json:"type"`
+type stage struct {
+	Type              string             `json:"type"`
+	IdentityProviders []identityProvider `json:"identity_providers,omitempty"`
 }
 
-func passwordLogin() flows {
-	f := flows{}
-	s := flow{
-		Type: "m.login.password",
+type identityProvider struct {
+	ID    string `json:"id"`
+	Name  string `json:"name"`
+	Brand string `json:"brand,omitempty"`
+	Icon  string `json:"icon,omitempty"`
+}
+
+func passwordLogin() []stage {
+	return []stage{
+		{Type: authtypes.LoginTypePassword},
+	}
+}
+
+func ssoLogin(cfg *config.ClientAPI) []stage {
+	var idps []identityProvider
+	for _, idp := range cfg.Login.SSO.Providers {
+		brand := idp.Brand
+		if brand == "" {
+			typ := idp.Type
+			if typ == "" {
+				typ = idp.ID
+			}
+			idpType := sso.GetIdentityProvider(sso.IdentityProviderType(typ))
+			if idpType != nil {
+				brand = idpType.DefaultBrand()
+			}
+		}
+		idps = append(idps, identityProvider{
+			ID:    idp.ID,
+			Name:  idp.Name,
+			Brand: brand,
+			Icon:  idp.Icon,
+		})
+	}
+	return []stage{
+		{
+			Type:              authtypes.LoginTypeSSO,
+			IdentityProviders: idps,
+		},
 	}
-	f.Flows = append(f.Flows, s)
-	return f
 }
 
 // Login implements GET and POST /login
@@ -57,10 +93,13 @@ func Login(
 	cfg *config.ClientAPI,
 ) util.JSONResponse {
 	if req.Method == http.MethodGet {
-		// TODO: support other forms of login other than password, depending on config options
+		allFlows := passwordLogin()
+		if cfg.Login.SSO.Enabled {
+			allFlows = append(allFlows, ssoLogin(cfg)...)
+		}
 		return util.JSONResponse{
 			Code: http.StatusOK,
-			JSON: passwordLogin(),
+			JSON: flows{Flows: allFlows},
 		}
 	} else if req.Method == http.MethodPost {
 		login, cleanup, authErr := auth.LoginFromJSONReader(req.Context(), req.Body, userAPI, userAPI, cfg)
@@ -72,6 +111,7 @@ func Login(
 		cleanup(req.Context(), &authErr2)
 		return authErr2
 	}
+
 	return util.JSONResponse{
 		Code: http.StatusMethodNotAllowed,
 		JSON: jsonerror.NotFound("Bad method"),
diff --git a/clientapi/routing/routing.go b/clientapi/routing/routing.go
index 94becf465a..a833e5217a 100644
--- a/clientapi/routing/routing.go
+++ b/clientapi/routing/routing.go
@@ -563,6 +563,25 @@ func Setup(
 		}),
 	).Methods(http.MethodGet, http.MethodPost, http.MethodOptions)
 
+	v3mux.Handle("/login/sso/callback",
+		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
+			return SSOCallback(req, userAPI, cfg)
+		}),
+	).Methods(http.MethodGet, http.MethodOptions)
+
+	v3mux.Handle("/login/sso/redirect",
+		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
+			return SSORedirect(req, "", cfg)
+		}),
+	).Methods(http.MethodGet, http.MethodOptions)
+
+	v3mux.Handle("/login/sso/redirect/{idpID}",
+		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
+			vars := mux.Vars(req)
+			return SSORedirect(req, vars["idpID"], cfg)
+		}),
+	).Methods(http.MethodGet, http.MethodOptions)
+
 	v3mux.Handle("/auth/{authType}/fallback/web",
 		httputil.MakeHTMLAPI("auth_fallback", func(w http.ResponseWriter, req *http.Request) *util.JSONResponse {
 			vars := mux.Vars(req)
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
new file mode 100644
index 0000000000..e9e4e55181
--- /dev/null
+++ b/clientapi/routing/sso.go
@@ -0,0 +1,283 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package routing
+
+import (
+	"context"
+	"encoding/base64"
+	"net/http"
+	"net/url"
+	"strings"
+	"time"
+
+	"github.com/matrix-org/dendrite/clientapi/auth/sso"
+	"github.com/matrix-org/dendrite/clientapi/jsonerror"
+	"github.com/matrix-org/dendrite/clientapi/userutil"
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+	"github.com/matrix-org/gomatrixserverlib"
+	"github.com/matrix-org/util"
+)
+
+// SSORedirect implements /login/sso/redirect
+// https://spec.matrix.org/v1.2/client-server-api/#redirecting-to-the-authentication-server
+func SSORedirect(
+	req *http.Request,
+	idpID string,
+	cfg *config.ClientAPI,
+) util.JSONResponse {
+	if !cfg.Login.SSO.Enabled {
+		return util.JSONResponse{
+			Code: http.StatusNotImplemented,
+			JSON: jsonerror.NotFound("authentication method disabled"),
+		}
+	}
+
+	redirectURL := req.URL.Query().Get("redirectUrl")
+	if redirectURL == "" {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.MissingArgument("redirectUrl parameter missing"),
+		}
+	}
+	_, err := url.Parse(redirectURL)
+	if err != nil {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.InvalidArgumentValue("Invalid redirectURL: " + err.Error()),
+		}
+	}
+
+	if idpID == "" {
+		// Check configuration if the client didn't provide an ID.
+		idpID = cfg.Login.SSO.DefaultProviderID
+	}
+	if idpID == "" && len(cfg.Login.SSO.Providers) > 0 {
+		// Fall back to the first provider. If there are no providers, getProvider("") will fail.
+		idpID = cfg.Login.SSO.Providers[0].ID
+	}
+	idpCfg, idpType := getProvider(cfg, idpID)
+	if idpType == nil {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.InvalidArgumentValue("unknown identity provider"),
+		}
+	}
+
+	idpReq := &sso.IdentityProviderRequest{
+		System:        idpCfg,
+		CallbackURL:   req.URL.ResolveReference(&url.URL{Path: "../callback", RawQuery: url.Values{"provider": []string{idpID}}.Encode()}).String(),
+		DendriteNonce: formatNonce(redirectURL),
+	}
+	u, err := idpType.AuthorizationURL(req.Context(), idpReq)
+	if err != nil {
+		return util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: err,
+		}
+	}
+
+	resp := util.RedirectResponse(u)
+	resp.Headers["Set-Cookie"] = (&http.Cookie{
+		Name:     "oidc_nonce",
+		Value:    idpReq.DendriteNonce,
+		Expires:  time.Now().Add(10 * time.Minute),
+		Secure:   true,
+		SameSite: http.SameSiteStrictMode,
+	}).String()
+	return resp
+}
+
+// SSOCallback implements /login/sso/callback.
+// https://spec.matrix.org/v1.2/client-server-api/#handling-the-callback-from-the-authentication-server
+func SSOCallback(
+	req *http.Request,
+	userAPI userAPIForSSO,
+	cfg *config.ClientAPI,
+) util.JSONResponse {
+	ctx := req.Context()
+
+	query := req.URL.Query()
+	idpID := query.Get("provider")
+	if idpID == "" {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.MissingArgument("provider parameter missing"),
+		}
+	}
+	idpCfg, idpType := getProvider(cfg, idpID)
+	if idpType == nil {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.InvalidArgumentValue("unknown identity provider"),
+		}
+	}
+
+	nonce, err := req.Cookie("oidc_nonce")
+	if err != nil {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.MissingArgument("no nonce cookie: " + err.Error()),
+		}
+	}
+	finalRedirectURL, err := parseNonce(nonce.Value)
+	if err != nil {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: err,
+		}
+	}
+
+	idpReq := &sso.IdentityProviderRequest{
+		System: idpCfg,
+		CallbackURL: (&url.URL{
+			Scheme: req.URL.Scheme,
+			Host:   req.URL.Host,
+			Path:   req.URL.Path,
+			RawQuery: url.Values{
+				"provider": []string{idpID},
+			}.Encode(),
+		}).String(),
+		DendriteNonce: nonce.Value,
+	}
+	result, err := idpType.ProcessCallback(ctx, idpReq, query)
+	if err != nil {
+		return util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: err,
+		}
+	}
+
+	if result.Identifier == nil {
+		// Not authenticated yet.
+		return util.RedirectResponse(result.RedirectURL)
+	}
+
+	id, err := verifyThirdPartyUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
+	if err != nil {
+		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier.String()).Error("failed to find user")
+		return util.JSONResponse{
+			Code: http.StatusUnauthorized,
+			JSON: jsonerror.Forbidden("ID not associated with a local account"),
+		}
+	}
+	if id == nil {
+		// The user doesn't exist.
+		// TODO: let the user select a localpart and register an account.
+		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier.String()).Error("failed to find user")
+		return util.JSONResponse{
+			Code: http.StatusNotImplemented,
+			JSON: jsonerror.Forbidden("SSO registration not implemented"),
+		}
+	}
+
+	token, err := createLoginToken(ctx, userAPI, id)
+	if err != nil {
+		util.GetLogger(ctx).WithError(err).Errorf("PerformLoginTokenCreation failed")
+		return jsonerror.InternalServerError()
+	}
+
+	rquery := finalRedirectURL.Query()
+	rquery.Set("loginToken", token.Token)
+	resp := util.RedirectResponse(finalRedirectURL.ResolveReference(&url.URL{RawQuery: rquery.Encode()}).String())
+	resp.Headers["Set-Cookie"] = (&http.Cookie{
+		Name:   "oidc_nonce",
+		Value:  "",
+		MaxAge: -1,
+		Secure: true,
+	}).String()
+	return resp
+}
+
+type userAPIForSSO interface {
+	uapi.LoginTokenInternalAPI
+
+	QueryLocalpartForThreePID(ctx context.Context, req *uapi.QueryLocalpartForThreePIDRequest, res *uapi.QueryLocalpartForThreePIDResponse) error
+}
+
+// getProvider looks up the given provider in the
+// configuration. Returns nil if it wasn't found or was of unknown
+// type.
+func getProvider(cfg *config.ClientAPI, id string) (*config.IdentityProvider, sso.IdentityProvider) {
+	for _, idp := range cfg.Login.SSO.Providers {
+		if idp.ID == id {
+			switch sso.IdentityProviderType(id) {
+			case sso.TypeGitHub:
+				return &idp, sso.GitHubIdentityProvider
+			default:
+				return nil, nil
+			}
+		}
+	}
+	return nil, nil
+}
+
+// formatNonce creates a random nonce that also contains the URL.
+func formatNonce(redirectURL string) string {
+	return util.RandomString(16) + "." + base64.RawURLEncoding.EncodeToString([]byte(redirectURL))
+}
+
+// parseNonce extracts the embedded URL from the nonce. The nonce
+// should have been validated to be the original before calling this
+// function. The URL is not integrity protected.
+func parseNonce(s string) (redirectURL *url.URL, _ error) {
+	if s == "" {
+		return nil, jsonerror.MissingArgument("empty OIDC nonce cookie")
+	}
+
+	ss := strings.Split(s, ".")
+	if len(ss) < 2 {
+		return nil, jsonerror.InvalidArgumentValue("malformed OIDC nonce cookie")
+	}
+
+	urlbs, err := base64.RawURLEncoding.DecodeString(ss[1])
+	if err != nil {
+		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in OIDC nonce cookie")
+	}
+	u, err := url.Parse(string(urlbs))
+	if err != nil {
+		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in OIDC nonce cookie: " + err.Error())
+	}
+
+	return u, nil
+}
+
+// verifyThirdPartyUserIdentifier resolves a ThirdPartyIdentifier to a
+// UserIdentifier using the User API. Returns nil if there is no
+// associated user.
+func verifyThirdPartyUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *userutil.ThirdPartyIdentifier, serverName gomatrixserverlib.ServerName) (*userutil.UserIdentifier, error) {
+	req := &uapi.QueryLocalpartForThreePIDRequest{
+		ThreePID: id.Address,
+		Medium:   string(id.Medium),
+	}
+	var res uapi.QueryLocalpartForThreePIDResponse
+	if err := userAPI.QueryLocalpartForThreePID(ctx, req, &res); err != nil {
+		return nil, err
+	}
+	if res.Localpart == "" {
+		return nil, nil
+	}
+
+	return &userutil.UserIdentifier{UserID: userutil.MakeUserID(res.Localpart, serverName)}, nil
+}
+
+func createLoginToken(ctx context.Context, userAPI userAPIForSSO, id *userutil.UserIdentifier) (*uapi.LoginTokenMetadata, error) {
+	req := uapi.PerformLoginTokenCreationRequest{Data: uapi.LoginTokenData{UserID: id.UserID}}
+	var resp uapi.PerformLoginTokenCreationResponse
+	if err := userAPI.PerformLoginTokenCreation(ctx, &req, &resp); err != nil {
+		return nil, err
+	}
+	return &resp.Metadata, nil
+}
diff --git a/clientapi/userutil/identifier.go b/clientapi/userutil/identifier.go
new file mode 100644
index 0000000000..e7e217484b
--- /dev/null
+++ b/clientapi/userutil/identifier.go
@@ -0,0 +1,153 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package userutil
+
+import (
+	"bytes"
+	"encoding/json"
+	"errors"
+)
+
+// An Identifier identifies a user. There are many kinds, and this is
+// the common interface for them.
+//
+// If you need to handle an identifier as JSON, use the AnyIdentifier wrapper.
+// Passing around identifiers in code, the raw Identifier is enough.
+//
+// See https://matrix.org/docs/spec/client_server/r0.6.1#identifier-types
+type Identifier interface {
+	// IdentifierType returns the identifier type, like "m.id.user".
+	IdentifierType() IdentifierType
+
+	// String returns a debug-output string representation. The format
+	// is not specified.
+	String() string
+}
+
+// A UserIdentifier contains an MXID. It may be only the local part.
+type UserIdentifier struct {
+	UserID string `json:"user"`
+}
+
+func (i *UserIdentifier) IdentifierType() IdentifierType { return IdentifierUser }
+func (i *UserIdentifier) String() string                 { return i.UserID }
+
+// A ThirdPartyIdentifier references an identifier in another system.
+type ThirdPartyIdentifier struct {
+	// Medium is normally MediumEmail.
+	Medium Medium `json:"medium"`
+
+	// Address is the medium-specific identifier.
+	Address string `json:"address"`
+}
+
+func (i *ThirdPartyIdentifier) IdentifierType() IdentifierType { return IdentifierThirdParty }
+func (i *ThirdPartyIdentifier) String() string                 { return string(i.Medium) + ":" + i.Address }
+
+// A PhoneIdentifier references a phone number.
+type PhoneIdentifier struct {
+	// Country is a ISO-3166-1 alpha-2 country code.
+	Country string `json:"country"`
+
+	// PhoneNumber is a country-specific phone number, as it would be dialled from.
+	PhoneNumber string `json:"phone"`
+}
+
+func (i *PhoneIdentifier) IdentifierType() IdentifierType { return IdentifierPhone }
+func (i *PhoneIdentifier) String() string                 { return i.Country + ":" + i.PhoneNumber }
+
+// UnknownIdentifier is the catch-all for identifiers this code doesn't know about.
+// It simply stores raw JSON.
+type UnknownIdentifier struct {
+	json.RawMessage
+	Type IdentifierType
+}
+
+func (i *UnknownIdentifier) IdentifierType() IdentifierType { return i.Type }
+func (i *UnknownIdentifier) String() string                 { return "unknown/" + string(i.Type) }
+
+// AnyIdentifier is a wrapper that allows marshalling and unmarshalling the various
+// types of identifiers to/from JSON. Always use this in data types that will be
+// used in JSON manipulation.
+type AnyIdentifier struct {
+	Identifier
+}
+
+func (i AnyIdentifier) MarshalJSON() ([]byte, error) {
+	v := struct {
+		*UserIdentifier
+		*ThirdPartyIdentifier
+		*PhoneIdentifier
+		Type IdentifierType `json:"type"`
+	}{
+		Type: i.Identifier.IdentifierType(),
+	}
+	switch iid := i.Identifier.(type) {
+	case *UserIdentifier:
+		v.UserIdentifier = iid
+	case *ThirdPartyIdentifier:
+		v.ThirdPartyIdentifier = iid
+	case *PhoneIdentifier:
+		v.PhoneIdentifier = iid
+	case *UnknownIdentifier:
+		return iid.RawMessage, nil
+	}
+	return json.Marshal(v)
+}
+
+func (i *AnyIdentifier) UnmarshalJSON(bs []byte) error {
+	var hdr struct {
+		Type IdentifierType `json:"type"`
+	}
+	if err := json.Unmarshal(bs, &hdr); err != nil {
+		return err
+	}
+	switch hdr.Type {
+	case IdentifierUser:
+		var ui UserIdentifier
+		i.Identifier = &ui
+		return json.Unmarshal(bs, &ui)
+	case IdentifierThirdParty:
+		var tpi ThirdPartyIdentifier
+		i.Identifier = &tpi
+		return json.Unmarshal(bs, &tpi)
+	case IdentifierPhone:
+		var pi PhoneIdentifier
+		i.Identifier = &pi
+		return json.Unmarshal(bs, &pi)
+	case "":
+		return errors.New("missing identifier type")
+	default:
+		i.Identifier = &UnknownIdentifier{RawMessage: json.RawMessage(bytes.TrimSpace(bs)), Type: hdr.Type}
+		return nil
+	}
+}
+
+// IdentifierType describes the type of identifier.
+type IdentifierType string
+
+const (
+	IdentifierUser       IdentifierType = "m.id.user"
+	IdentifierThirdParty IdentifierType = "m.id.thirdparty"
+	IdentifierPhone      IdentifierType = "m.id.phone"
+)
+
+// Medium describes the interpretation of a third-party identifier.
+type Medium string
+
+const (
+	// MediumEmail signifies that the address is an email address.
+	MediumEmail Medium = "email"
+)
diff --git a/clientapi/userutil/identifier_test.go b/clientapi/userutil/identifier_test.go
new file mode 100644
index 0000000000..906cbba162
--- /dev/null
+++ b/clientapi/userutil/identifier_test.go
@@ -0,0 +1,75 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package userutil
+
+import (
+	"encoding/json"
+	"reflect"
+	"testing"
+)
+
+func TestAnyIdentifierJSON(t *testing.T) {
+	tsts := []struct {
+		Name string
+		JSON string
+		Want Identifier
+	}{
+		{Name: "empty", JSON: `{}`},
+		{Name: "user", JSON: `{"type":"m.id.user","user":"auser"}`, Want: &UserIdentifier{UserID: "auser"}},
+		{Name: "thirdparty", JSON: `{"type":"m.id.thirdparty","medium":"email","address":"auser@example.com"}`, Want: &ThirdPartyIdentifier{Medium: "email", Address: "auser@example.com"}},
+		{Name: "phone", JSON: `{"type":"m.id.phone","country":"GB","phone":"123456789"}`, Want: &PhoneIdentifier{Country: "GB", PhoneNumber: "123456789"}},
+		// This test is a little fragile since it compares the output of json.Marshal.
+		{Name: "unknown", JSON: `{"type":"other"}`, Want: &UnknownIdentifier{Type: "other", RawMessage: json.RawMessage(`{"type":"other"}`)}},
+	}
+	for _, tst := range tsts {
+		t.Run("Unmarshal/"+tst.Name, func(t *testing.T) {
+			var got AnyIdentifier
+			if err := json.Unmarshal([]byte(tst.JSON), &got); err != nil {
+				if tst.Want == nil {
+					return
+				}
+				t.Fatalf("Unmarshal failed: %v", err)
+			}
+
+			if !reflect.DeepEqual(got.Identifier, tst.Want) {
+				t.Errorf("got %+v, want %+v", got.Identifier, tst.Want)
+			}
+		})
+
+		if tst.Want == nil {
+			continue
+		}
+		t.Run("Marshal/"+tst.Name, func(t *testing.T) {
+			id := AnyIdentifier{Identifier: tst.Want}
+			bs, err := json.Marshal(id)
+			if err != nil {
+				t.Fatalf("Marshal failed: %v", err)
+			}
+			t.Logf("Marshalled JSON: %q", string(bs))
+
+			var got AnyIdentifier
+			if err := json.Unmarshal(bs, &got); err != nil {
+				if tst.Want == nil {
+					return
+				}
+				t.Fatalf("Unmarshal failed: %v", err)
+			}
+
+			if !reflect.DeepEqual(got.Identifier, tst.Want) {
+				t.Errorf("got %+v, want %+v", got.Identifier, tst.Want)
+			}
+		})
+	}
+}
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index bb786a1457..3781a8264c 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -42,6 +42,8 @@ type ClientAPI struct {
 	// was successful
 	RecaptchaSiteVerifyAPI string `yaml:"recaptcha_siteverify_api"`
 
+	Login Login `yaml:"login"`
+
 	// TURN options
 	TURN TURN `yaml:"turn"`
 
@@ -64,9 +66,11 @@ func (c *ClientAPI) Defaults(generate bool) {
 	c.RegistrationDisabled = true
 	c.OpenRegistrationWithoutVerificationEnabled = false
 	c.RateLimiting.Defaults()
+	c.Login.SSO.Enabled = false
 }
 
 func (c *ClientAPI) Verify(configErrs *ConfigErrors, isMonolith bool) {
+	c.Login.Verify(configErrs)
 	c.TURN.Verify(configErrs)
 	c.RateLimiting.Verify(configErrs)
 	if c.RecaptchaEnabled {
@@ -95,6 +99,125 @@ func (c *ClientAPI) Verify(configErrs *ConfigErrors, isMonolith bool) {
 	checkURL(configErrs, "client_api.external_api.listen", string(c.ExternalAPI.Listen))
 }
 
+type Login struct {
+	SSO SSO `yaml:"sso"`
+}
+
+func (l *Login) Verify(configErrs *ConfigErrors) {
+	l.SSO.Verify(configErrs)
+}
+
+type SSO struct {
+	// Enabled determines whether SSO should be allowed.
+	Enabled bool `yaml:"enabled"`
+
+	// Providers list the identity providers this server is capable of confirming an
+	// identity with.
+	Providers []IdentityProvider `yaml:"providers"`
+
+	// DefaultProviderID is the provider to use when the client doesn't indicate one.
+	// This is legacy support. If empty, the first provider listed is used.
+	DefaultProviderID string `yaml:"default_provider"`
+}
+
+func (sso *SSO) Verify(configErrs *ConfigErrors) {
+	var foundDefaultProvider bool
+	seenPIDs := make(map[string]bool, len(sso.Providers))
+	for _, p := range sso.Providers {
+		p.Verify(configErrs)
+		if p.ID == sso.DefaultProviderID {
+			foundDefaultProvider = true
+		}
+		if seenPIDs[p.ID] {
+			configErrs.Add(fmt.Sprintf("duplicate identity provider for config key %q: %s", "client_api.sso.providers", p.ID))
+		}
+		seenPIDs[p.ID] = true
+	}
+	if sso.DefaultProviderID != "" && !foundDefaultProvider {
+		configErrs.Add(fmt.Sprintf("identity provider ID not found for config key %q: %s", "client_api.sso.default_provider", sso.DefaultProviderID))
+	}
+
+	if sso.Enabled {
+		if len(sso.Providers) == 0 {
+			configErrs.Add(fmt.Sprintf("empty list for config key %q", "client_api.sso.providers"))
+		}
+	}
+}
+
+// See https://github.com/matrix-org/matrix-doc/blob/old_master/informal/idp-brands.md.
+type IdentityProvider struct {
+	// ID is the unique identifier of this IdP. We use the brand identifiers as provider
+	// identifiers for simplicity.
+	ID string `yaml:"id"`
+
+	// Name is a human-friendly name of the provider.
+	Name string `yaml:"name"`
+
+	// Brand is a hint on how to display the IdP to the user. If this is empty, a default
+	// based on the type is used.
+	Brand string `yaml:"brand"`
+
+	// Icon is an MXC URI describing how to display the IdP to the user. Prefer using `brand`.
+	Icon string `yaml:"icon"`
+
+	// Type describes how this provider is implemented. It must match "github". If this is
+	// empty, the ID is used, which means there is a weak expectation that ID is also a
+	// valid type, unless you have a complicated setup.
+	Type string `yaml:"type"`
+
+	// OIDC contains settings for providers based on OpenID Connect (OAuth 2).
+	OIDC struct {
+		ClientID     string `yaml:"client_id"`
+		ClientSecret string `yaml:"client_secret"`
+	} `yaml:"oidc"`
+}
+
+func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
+	checkNotEmpty(configErrs, "client_api.sso.providers.id", idp.ID)
+	if !checkIdentityProviderBrand(idp.ID) {
+		configErrs.Add(fmt.Sprintf("unrecognized ID config key %q: %s", "client_api.sso.providers", idp.ID))
+	}
+	checkNotEmpty(configErrs, "client_api.sso.providers.name", idp.Name)
+	if idp.Brand != "" && !checkIdentityProviderBrand(idp.Brand) {
+		configErrs.Add(fmt.Sprintf("unrecognized brand in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Brand))
+	}
+	if idp.Icon != "" {
+		checkURL(configErrs, "client_api.sso.providers.icon", idp.Icon)
+	}
+	typ := idp.Type
+	if idp.Type == "" {
+		typ = idp.ID
+	}
+
+	switch typ {
+	case "github":
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
+
+	default:
+		configErrs.Add(fmt.Sprintf("unrecognized type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", typ))
+	}
+}
+
+// See https://github.com/matrix-org/matrix-doc/blob/old_master/informal/idp-brands.md.
+func checkIdentityProviderBrand(s string) bool {
+	switch s {
+	case SSOBrandApple, SSOBrandFacebook, SSOBrandGitHub, SSOBrandGitLab, SSOBrandGoogle, SSOBrandTwitter:
+		return true
+	default:
+		return false
+	}
+}
+
+const (
+	SSOBrandApple    = "apple"
+	SSOBrandFacebook = "facebook"
+	SSOBrandGitHub   = "github"
+	SSOBrandGitLab   = "gitlab"
+	SSOBrandGoogle   = "google"
+	SSOBrandTwitter  = "twitter"
+)
+
 type TURN struct {
 	// TODO Guest Support
 	// Whether or not guests can request TURN credentials

From c1c2a0448c582f8081e27d0677239ad7561b2b3f Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 23 May 2022 11:37:27 +0200
Subject: [PATCH 03/35] Disable m.login.token if there are no enabled login
 methods to use it.

---
 clientapi/auth/login.go          |  8 ++++++++
 clientapi/auth/login_test.go     | 10 ++++++++++
 clientapi/routing/login.go       | 21 ++++++++++++++++++---
 setup/config/config_clientapi.go |  6 ++++++
 4 files changed, 42 insertions(+), 3 deletions(-)

diff --git a/clientapi/auth/login.go b/clientapi/auth/login.go
index 5f51c662aa..7cd8bb4547 100644
--- a/clientapi/auth/login.go
+++ b/clientapi/auth/login.go
@@ -62,6 +62,14 @@ func LoginFromJSONReader(ctx context.Context, r io.Reader, useraccountAPI uapi.U
 			Config:               cfg,
 		}
 	case authtypes.LoginTypeToken:
+		if !cfg.Login.LoginTokenEnabled() {
+			err := util.JSONResponse{
+				Code: http.StatusBadRequest,
+				JSON: jsonerror.InvalidArgumentValue("disabled login type: " + header.Type),
+			}
+			return nil, nil, &err
+		}
+
 		typ = &LoginTypeToken{
 			UserAPI: userAPI,
 			Config:  cfg,
diff --git a/clientapi/auth/login_test.go b/clientapi/auth/login_test.go
index 5085f0170c..cb57e95526 100644
--- a/clientapi/auth/login_test.go
+++ b/clientapi/auth/login_test.go
@@ -68,6 +68,11 @@ func TestLoginFromJSONReader(t *testing.T) {
 				Matrix: &config.Global{
 					ServerName: serverName,
 				},
+				Login: config.Login{
+					SSO: config.SSO{
+						Enabled: true,
+					},
+				},
 			}
 			login, cleanup, err := LoginFromJSONReader(ctx, strings.NewReader(tst.Body), &userAPI, &userAPI, cfg)
 			if err != nil {
@@ -146,6 +151,11 @@ func TestBadLoginFromJSONReader(t *testing.T) {
 				Matrix: &config.Global{
 					ServerName: serverName,
 				},
+				Login: config.Login{
+					SSO: config.SSO{
+						Enabled: true,
+					},
+				},
 			}
 			_, cleanup, errRes := LoginFromJSONReader(ctx, strings.NewReader(tst.Body), &userAPI, &userAPI, cfg)
 			if errRes == nil {
diff --git a/clientapi/routing/login.go b/clientapi/routing/login.go
index 97b3979289..ad4aca29cb 100644
--- a/clientapi/routing/login.go
+++ b/clientapi/routing/login.go
@@ -59,6 +59,10 @@ func passwordLogin() []stage {
 }
 
 func ssoLogin(cfg *config.ClientAPI) []stage {
+	if !cfg.Login.SSO.Enabled {
+		return nil
+	}
+
 	var idps []identityProvider
 	for _, idp := range cfg.Login.SSO.Providers {
 		brand := idp.Brand
@@ -87,6 +91,18 @@ func ssoLogin(cfg *config.ClientAPI) []stage {
 	}
 }
 
+func tokenLogin(cfg *config.ClientAPI) []stage {
+	if !cfg.Login.LoginTokenEnabled() {
+		return nil
+	}
+
+	return []stage{
+		{
+			Type: authtypes.LoginTypeToken,
+		},
+	}
+}
+
 // Login implements GET and POST /login
 func Login(
 	req *http.Request, userAPI userapi.ClientUserAPI,
@@ -94,9 +110,8 @@ func Login(
 ) util.JSONResponse {
 	if req.Method == http.MethodGet {
 		allFlows := passwordLogin()
-		if cfg.Login.SSO.Enabled {
-			allFlows = append(allFlows, ssoLogin(cfg)...)
-		}
+		allFlows = append(allFlows, ssoLogin(cfg)...)
+		allFlows = append(allFlows, tokenLogin(cfg)...)
 		return util.JSONResponse{
 			Code: http.StatusOK,
 			JSON: flows{Flows: allFlows},
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 3781a8264c..4f529dd8eb 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -103,6 +103,12 @@ type Login struct {
 	SSO SSO `yaml:"sso"`
 }
 
+// LoginTokenEnabled returns whether any login type uses
+// authtypes.LoginTypeToken.
+func (l *Login) LoginTokenEnabled() bool {
+	return l.SSO.Enabled
+}
+
 func (l *Login) Verify(configErrs *ConfigErrors) {
 	l.SSO.Verify(configErrs)
 }

From c9ad7206c83baabf7a63cf1cf37295e865d53cae Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 23 May 2022 14:18:05 +0200
Subject: [PATCH 04/35] Enable SyTest "login types include SSO"

---
 sytest-whitelist | 1 +
 1 file changed, 1 insertion(+)

diff --git a/sytest-whitelist b/sytest-whitelist
index 6af8d89ff0..18917c1cfc 100644
--- a/sytest-whitelist
+++ b/sytest-whitelist
@@ -257,6 +257,7 @@ Real non-joined users cannot room initalSync for non-world_readable rooms
 Push rules come down in an initial /sync
 Regular users can add and delete aliases in the default room configuration
 GET /v3/capabilities is not public
+login types include SSO
 GET /joined_rooms lists newly-created room
 /joined_rooms returns only joined rooms
 Message history can be paginated over federation

From c3f7945284b52b3a60da06a27f13c4ce43e0c310 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 23 May 2022 17:38:30 +0200
Subject: [PATCH 05/35] Add SSO UserAPI endpoints.

This is mostly copied from the ThirdPID, but with a primary key that
matches OpenID Connect nomenclature. There's a namspace to ensure
other SSO solutions can be supported, but there's only one namespace
defined for now.
---
 userapi/api/api.go                    |  1 +
 userapi/api/api_sso.go                | 53 +++++++++++++++
 userapi/api/api_trace_sso.go          | 39 +++++++++++
 userapi/internal/api_sso.go           | 50 ++++++++++++++
 userapi/inthttp/client_sso.go         | 53 +++++++++++++++
 userapi/inthttp/server.go             |  1 +
 userapi/inthttp/server_sso.go         | 66 +++++++++++++++++++
 userapi/storage/interface.go          |  7 ++
 userapi/storage/postgres/sso_table.go | 93 +++++++++++++++++++++++++++
 userapi/storage/shared/storage.go     | 30 +++++++++
 userapi/storage/sqlite3/sso_table.go  | 93 +++++++++++++++++++++++++++
 userapi/storage/tables/interface.go   |  6 ++
 12 files changed, 492 insertions(+)
 create mode 100644 userapi/api/api_sso.go
 create mode 100644 userapi/api/api_trace_sso.go
 create mode 100644 userapi/internal/api_sso.go
 create mode 100644 userapi/inthttp/client_sso.go
 create mode 100644 userapi/inthttp/server_sso.go
 create mode 100644 userapi/storage/postgres/sso_table.go
 create mode 100644 userapi/storage/sqlite3/sso_table.go

diff --git a/userapi/api/api.go b/userapi/api/api.go
index df9408acbf..ac38927bba 100644
--- a/userapi/api/api.go
+++ b/userapi/api/api.go
@@ -77,6 +77,7 @@ type SyncUserAPI interface {
 type ClientUserAPI interface {
 	QueryAcccessTokenAPI
 	LoginTokenInternalAPI
+	SSOAPI
 	UserLoginAPI
 	QueryNumericLocalpart(ctx context.Context, res *QueryNumericLocalpartResponse) error
 	QueryDevices(ctx context.Context, req *QueryDevicesRequest, res *QueryDevicesResponse) error
diff --git a/userapi/api/api_sso.go b/userapi/api/api_sso.go
new file mode 100644
index 0000000000..56a3686b97
--- /dev/null
+++ b/userapi/api/api_sso.go
@@ -0,0 +1,53 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package api
+
+import (
+	"context"
+)
+
+type SSOAPI interface {
+	QueryLocalpartForSSO(ctx context.Context, req *QueryLocalpartForSSORequest, res *QueryLocalpartForSSOResponse) error
+	PerformForgetSSO(ctx context.Context, req *PerformForgetSSORequest, res *struct{}) error
+	PerformSaveSSOAssociation(ctx context.Context, req *PerformSaveSSOAssociationRequest, res *struct{}) error
+}
+
+type QueryLocalpartForSSORequest struct {
+	Namespace       SSOIssuerNamespace
+	Issuer, Subject string
+}
+
+type QueryLocalpartForSSOResponse struct {
+	Localpart string
+}
+
+type PerformForgetSSORequest QueryLocalpartForSSORequest
+
+type PerformSaveSSOAssociationRequest struct {
+	Namespace       SSOIssuerNamespace
+	Issuer, Subject string
+	Localpart       string
+}
+
+// An SSOIssuerNamespace defines the interpretation of an issuer.
+type SSOIssuerNamespace string
+
+const (
+	UnknownNamespace SSOIssuerNamespace = ""
+
+	// OIDCNamespace indicates the issuer is a full URL, as defined in
+	// https://openid.net/specs/openid-connect-core-1_0.html#Terminology.
+	OIDCNamespace SSOIssuerNamespace = "oidc"
+)
diff --git a/userapi/api/api_trace_sso.go b/userapi/api/api_trace_sso.go
new file mode 100644
index 0000000000..0a836f84a0
--- /dev/null
+++ b/userapi/api/api_trace_sso.go
@@ -0,0 +1,39 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package api
+
+import (
+	"context"
+
+	"github.com/matrix-org/util"
+)
+
+func (t *UserInternalAPITrace) QueryLocalpartForSSO(ctx context.Context, req *QueryLocalpartForSSORequest, res *QueryLocalpartForSSOResponse) error {
+	err := t.Impl.QueryLocalpartForSSO(ctx, req, res)
+	util.GetLogger(ctx).Infof("QueryLocalpartForSSO req=%+v res=%+v", js(req), js(res))
+	return err
+}
+
+func (t *UserInternalAPITrace) PerformForgetSSO(ctx context.Context, req *PerformForgetSSORequest, res *struct{}) error {
+	err := t.Impl.PerformForgetSSO(ctx, req, res)
+	util.GetLogger(ctx).Infof("PerformForgetSSO req=%+v res=%+v", js(req), js(res))
+	return err
+}
+
+func (t *UserInternalAPITrace) PerformSaveSSOAssociation(ctx context.Context, req *PerformSaveSSOAssociationRequest, res *struct{}) error {
+	err := t.Impl.PerformSaveSSOAssociation(ctx, req, res)
+	util.GetLogger(ctx).Infof("PerformSaveSSOAssociation req=%+v res=%+v", js(req), js(res))
+	return err
+}
diff --git a/userapi/internal/api_sso.go b/userapi/internal/api_sso.go
new file mode 100644
index 0000000000..171c318722
--- /dev/null
+++ b/userapi/internal/api_sso.go
@@ -0,0 +1,50 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package internal
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/matrix-org/dendrite/userapi/api"
+)
+
+func (a *UserInternalAPI) QueryLocalpartForSSO(ctx context.Context, req *api.QueryLocalpartForSSORequest, res *api.QueryLocalpartForSSOResponse) error {
+	var err error
+	res.Localpart, err = a.DB.GetLocalpartForSSO(ctx, string(req.Namespace), req.Issuer, req.Subject)
+	return err
+}
+
+func (a *UserInternalAPI) PerformForgetSSO(ctx context.Context, req *api.PerformForgetSSORequest, res *struct{}) error {
+	return a.DB.RemoveSSOAssociation(ctx, string(req.Namespace), req.Issuer, req.Subject)
+}
+
+func (a *UserInternalAPI) PerformSaveSSOAssociation(ctx context.Context, req *api.PerformSaveSSOAssociationRequest, res *struct{}) error {
+	ns, err := validateSSOIssuerNamespace(req.Namespace)
+	if err != nil {
+		return err
+	}
+	return a.DB.SaveSSOAssociation(ctx, ns, req.Issuer, req.Subject, req.Localpart)
+}
+
+func validateSSOIssuerNamespace(ns api.SSOIssuerNamespace) (string, error) {
+	switch ns {
+	case api.OIDCNamespace:
+		return string(ns), nil
+
+	default:
+		return "", fmt.Errorf("invalid SSO issuer namespace: %s", ns)
+	}
+}
diff --git a/userapi/inthttp/client_sso.go b/userapi/inthttp/client_sso.go
new file mode 100644
index 0000000000..e34130ed0e
--- /dev/null
+++ b/userapi/inthttp/client_sso.go
@@ -0,0 +1,53 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package inthttp
+
+import (
+	"context"
+
+	"github.com/matrix-org/dendrite/internal/httputil"
+	"github.com/matrix-org/dendrite/userapi/api"
+	"github.com/opentracing/opentracing-go"
+)
+
+const (
+	PerformForgetSSOPath          = "/userapi/performForgetSSO"
+	PerformSaveSSOAssociationPath = "/userapi/performSaveSSOAssociation"
+	QueryLocalpartForSSOPath      = "/userapi/queryLocalpartForSSO"
+)
+
+func (h *httpUserInternalAPI) QueryLocalpartForSSO(ctx context.Context, req *api.QueryLocalpartForSSORequest, res *api.QueryLocalpartForSSOResponse) error {
+	span, ctx := opentracing.StartSpanFromContext(ctx, QueryLocalpartForSSOPath)
+	defer span.Finish()
+
+	apiURL := h.apiURL + QueryLocalpartForSSOPath
+	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+}
+
+func (h *httpUserInternalAPI) PerformForgetSSO(ctx context.Context, req *api.PerformForgetSSORequest, res *struct{}) error {
+	span, ctx := opentracing.StartSpanFromContext(ctx, PerformForgetSSOPath)
+	defer span.Finish()
+
+	apiURL := h.apiURL + PerformForgetSSOPath
+	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+}
+
+func (h *httpUserInternalAPI) PerformSaveSSOAssociation(ctx context.Context, req *api.PerformSaveSSOAssociationRequest, res *struct{}) error {
+	span, ctx := opentracing.StartSpanFromContext(ctx, PerformSaveSSOAssociationPath)
+	defer span.Finish()
+
+	apiURL := h.apiURL + PerformSaveSSOAssociationPath
+	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+}
diff --git a/userapi/inthttp/server.go b/userapi/inthttp/server.go
index ad532b901a..2ed7a1d695 100644
--- a/userapi/inthttp/server.go
+++ b/userapi/inthttp/server.go
@@ -28,6 +28,7 @@ import (
 // nolint: gocyclo
 func AddRoutes(internalAPIMux *mux.Router, s api.UserInternalAPI) {
 	addRoutesLoginToken(internalAPIMux, s)
+	addRoutesSSO(internalAPIMux, s)
 
 	internalAPIMux.Handle(PerformAccountCreationPath,
 		httputil.MakeInternalAPI("performAccountCreation", func(req *http.Request) util.JSONResponse {
diff --git a/userapi/inthttp/server_sso.go b/userapi/inthttp/server_sso.go
new file mode 100644
index 0000000000..6e362a9701
--- /dev/null
+++ b/userapi/inthttp/server_sso.go
@@ -0,0 +1,66 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package inthttp
+
+import (
+	"encoding/json"
+	"net/http"
+
+	"github.com/gorilla/mux"
+	"github.com/matrix-org/dendrite/internal/httputil"
+	"github.com/matrix-org/dendrite/userapi/api"
+	"github.com/matrix-org/util"
+)
+
+// addRoutesSSO adds routes for all SSO API calls.
+func addRoutesSSO(internalAPIMux *mux.Router, s api.UserInternalAPI) {
+	internalAPIMux.Handle(QueryLocalpartForSSOPath,
+		httputil.MakeInternalAPI("queryLocalpartForSSO", func(req *http.Request) util.JSONResponse {
+			request := api.QueryLocalpartForSSORequest{}
+			response := api.QueryLocalpartForSSOResponse{}
+			if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
+				return util.MessageResponse(http.StatusBadRequest, err.Error())
+			}
+			if err := s.QueryLocalpartForSSO(req.Context(), &request, &response); err != nil {
+				return util.ErrorResponse(err)
+			}
+			return util.JSONResponse{Code: http.StatusOK, JSON: &response}
+		}),
+	)
+	internalAPIMux.Handle(PerformForgetSSOPath,
+		httputil.MakeInternalAPI("performForgetSSO", func(req *http.Request) util.JSONResponse {
+			request := api.PerformForgetSSORequest{}
+			if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
+				return util.MessageResponse(http.StatusBadRequest, err.Error())
+			}
+			if err := s.PerformForgetSSO(req.Context(), &request, &struct{}{}); err != nil {
+				return util.ErrorResponse(err)
+			}
+			return util.JSONResponse{Code: http.StatusOK, JSON: &struct{}{}}
+		}),
+	)
+	internalAPIMux.Handle(PerformSaveSSOAssociationPath,
+		httputil.MakeInternalAPI("performSaveSSOAssociation", func(req *http.Request) util.JSONResponse {
+			request := api.PerformSaveSSOAssociationRequest{}
+			if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
+				return util.MessageResponse(http.StatusBadRequest, err.Error())
+			}
+			if err := s.PerformSaveSSOAssociation(req.Context(), &request, &struct{}{}); err != nil {
+				return util.ErrorResponse(err)
+			}
+			return util.JSONResponse{Code: http.StatusOK, JSON: &struct{}{}}
+		}),
+	)
+}
diff --git a/userapi/storage/interface.go b/userapi/storage/interface.go
index f7cd1810ac..9ddb0f9b93 100644
--- a/userapi/storage/interface.go
+++ b/userapi/storage/interface.go
@@ -109,6 +109,12 @@ type Pusher interface {
 	RemovePushers(ctx context.Context, appid, pushkey string) error
 }
 
+type SSO interface {
+	SaveSSOAssociation(ctx context.Context, namespace, iss, sub, localpart string) error
+	RemoveSSOAssociation(ctx context.Context, namespace, iss, sub string) error
+	GetLocalpartForSSO(ctx context.Context, namespace, iss, sub string) (string, error)
+}
+
 type ThreePID interface {
 	SaveThreePIDAssociation(ctx context.Context, threepid, localpart, medium string) (err error)
 	RemoveThreePIDAssociation(ctx context.Context, threepid string, medium string) (err error)
@@ -136,6 +142,7 @@ type Database interface {
 	OpenID
 	Profile
 	Pusher
+	SSO
 	Statistics
 	ThreePID
 }
diff --git a/userapi/storage/postgres/sso_table.go b/userapi/storage/postgres/sso_table.go
new file mode 100644
index 0000000000..b04e69f552
--- /dev/null
+++ b/userapi/storage/postgres/sso_table.go
@@ -0,0 +1,93 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package postgres
+
+import (
+	"context"
+	"database/sql"
+
+	"github.com/matrix-org/dendrite/internal/sqlutil"
+	"github.com/matrix-org/dendrite/userapi/storage/tables"
+)
+
+const ssoSchema = `
+-- Stores data about SSO associations.
+CREATE TABLE IF NOT EXISTS account_sso (
+	-- The "iss" namespace. Must be "oidc".
+	namespace TEXT NOT NULL,
+    -- The issuer; for "oidc", a URL.
+	iss TEXT NOT NULL,
+    -- The subject (user ID).
+	sub TEXT NOT NULL,
+	-- The localpart of the Matrix user ID associated to this 3PID
+	localpart TEXT NOT NULL,
+
+	PRIMARY KEY(namespace, iss, sub)
+);
+`
+
+const selectLocalpartForSSOSQL = "" +
+	"SELECT localpart FROM account_sso WHERE namespace = $1 AND iss = $2 AND sub = $3"
+
+const insertSSOSQL = "" +
+	"INSERT INTO account_sso (namespace, iss, sub, localpart) VALUES ($1, $2, $3, $4)"
+
+const deleteSSOSQL = "" +
+	"DELETE FROM account_sso WHERE namespace = $1 AND iss = $2 AND sub = $3"
+
+type ssoStatements struct {
+	selectLocalpartForSSOStmt *sql.Stmt
+	insertSSOStmt             *sql.Stmt
+	deleteSSOStmt             *sql.Stmt
+}
+
+func NewPostgresSSOTable(db *sql.DB) (tables.SSOTable, error) {
+	s := &ssoStatements{}
+	_, err := db.Exec(ssoSchema)
+	if err != nil {
+		return nil, err
+	}
+	return s, sqlutil.StatementList{
+		{&s.selectLocalpartForSSOStmt, selectLocalpartForSSOSQL},
+		{&s.insertSSOStmt, insertSSOSQL},
+		{&s.deleteSSOStmt, deleteSSOSQL},
+	}.Prepare(db)
+}
+
+func (s *ssoStatements) SelectLocalpartForSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub string,
+) (localpart string, err error) {
+	stmt := sqlutil.TxStmt(txn, s.selectLocalpartForSSOStmt)
+	err = stmt.QueryRowContext(ctx, namespace, iss, sub).Scan(&localpart)
+	if err == sql.ErrNoRows {
+		return "", nil
+	}
+	return
+}
+
+func (s *ssoStatements) InsertSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub, localpart string,
+) (err error) {
+	stmt := sqlutil.TxStmt(txn, s.insertSSOStmt)
+	_, err = stmt.ExecContext(ctx, namespace, iss, sub, localpart)
+	return
+}
+
+func (s *ssoStatements) DeleteSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub string) (err error) {
+	stmt := sqlutil.TxStmt(txn, s.deleteSSOStmt)
+	_, err = stmt.ExecContext(ctx, namespace, iss, sub)
+	return
+}
diff --git a/userapi/storage/shared/storage.go b/userapi/storage/shared/storage.go
index 0cf713dac7..c44968406c 100644
--- a/userapi/storage/shared/storage.go
+++ b/userapi/storage/shared/storage.go
@@ -52,6 +52,7 @@ type Database struct {
 	LoginTokens           tables.LoginTokenTable
 	Notifications         tables.NotificationTable
 	Pushers               tables.PusherTable
+	SSOs                  tables.SSOTable
 	Stats                 tables.StatsTable
 	LoginTokenLifetime    time.Duration
 	ServerName            gomatrixserverlib.ServerName
@@ -225,6 +226,35 @@ func (d *Database) hashPassword(plaintext string) (hash string, err error) {
 	return string(hashBytes), err
 }
 
+var ErrSSOInUse = errors.New("this SSO account is already in use")
+
+func (d *Database) SaveSSOAssociation(ctx context.Context, namespace, iss, sub, localpart string) error {
+	return d.Writer.Do(d.DB, nil, func(txn *sql.Tx) error {
+		user, err := d.SSOs.SelectLocalpartForSSO(
+			ctx, txn, namespace, iss, sub,
+		)
+		if err != nil {
+			return err
+		}
+
+		if len(user) > 0 {
+			return Err3PIDInUse
+		}
+
+		return d.SSOs.InsertSSO(ctx, txn, namespace, iss, sub, localpart)
+	})
+}
+
+func (d *Database) RemoveSSOAssociation(ctx context.Context, namespace, iss, sub string) error {
+	return d.Writer.Do(d.DB, nil, func(txn *sql.Tx) error {
+		return d.SSOs.DeleteSSO(ctx, txn, namespace, iss, sub)
+	})
+}
+
+func (d *Database) GetLocalpartForSSO(ctx context.Context, namespace, iss, sub string) (string, error) {
+	return d.SSOs.SelectLocalpartForSSO(ctx, nil, namespace, iss, sub)
+}
+
 // Err3PIDInUse is the error returned when trying to save an association involving
 // a third-party identifier which is already associated to a local user.
 var Err3PIDInUse = errors.New("this third-party identifier is already in use")
diff --git a/userapi/storage/sqlite3/sso_table.go b/userapi/storage/sqlite3/sso_table.go
new file mode 100644
index 0000000000..16aede65bd
--- /dev/null
+++ b/userapi/storage/sqlite3/sso_table.go
@@ -0,0 +1,93 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sqlite3
+
+import (
+	"context"
+	"database/sql"
+
+	"github.com/matrix-org/dendrite/internal/sqlutil"
+	"github.com/matrix-org/dendrite/userapi/storage/tables"
+)
+
+const ssoSchema = `
+-- Stores data about SSO associations.
+CREATE TABLE IF NOT EXISTS account_sso (
+	-- The "iss" namespace. Must be "oidc".
+	namespace TEXT NOT NULL,
+    -- The issuer; for "oidc", a URL.
+	iss TEXT NOT NULL,
+    -- The subject (user ID).
+	sub TEXT NOT NULL,
+	-- The localpart of the Matrix user ID associated to this 3PID
+	localpart TEXT NOT NULL,
+
+	PRIMARY KEY(namespace, iss, sub)
+);
+`
+
+const selectLocalpartForSSOSQL = "" +
+	"SELECT localpart FROM account_sso WHERE namespace = $1 AND iss = $2 AND sub = $3"
+
+const insertSSOSQL = "" +
+	"INSERT INTO account_sso (namespace, iss, sub, localpart) VALUES ($1, $2, $3, $4)"
+
+const deleteSSOSQL = "" +
+	"DELETE FROM account_sso WHERE namespace = $1 AND iss = $2 AND sub = $3"
+
+type ssoStatements struct {
+	selectLocalpartForSSOStmt *sql.Stmt
+	insertSSOStmt             *sql.Stmt
+	deleteSSOStmt             *sql.Stmt
+}
+
+func NewSQLiteSSOTable(db *sql.DB) (tables.SSOTable, error) {
+	s := &ssoStatements{}
+	_, err := db.Exec(ssoSchema)
+	if err != nil {
+		return nil, err
+	}
+	return s, sqlutil.StatementList{
+		{&s.selectLocalpartForSSOStmt, selectLocalpartForSSOSQL},
+		{&s.insertSSOStmt, insertSSOSQL},
+		{&s.deleteSSOStmt, deleteSSOSQL},
+	}.Prepare(db)
+}
+
+func (s *ssoStatements) SelectLocalpartForSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub string,
+) (localpart string, err error) {
+	stmt := sqlutil.TxStmt(txn, s.selectLocalpartForSSOStmt)
+	err = stmt.QueryRowContext(ctx, namespace, iss, sub).Scan(&localpart)
+	if err == sql.ErrNoRows {
+		return "", nil
+	}
+	return
+}
+
+func (s *ssoStatements) InsertSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub, localpart string,
+) (err error) {
+	stmt := sqlutil.TxStmt(txn, s.insertSSOStmt)
+	_, err = stmt.ExecContext(ctx, namespace, iss, sub, localpart)
+	return
+}
+
+func (s *ssoStatements) DeleteSSO(
+	ctx context.Context, txn *sql.Tx, namespace, iss, sub string) (err error) {
+	stmt := sqlutil.TxStmt(txn, s.deleteSSOStmt)
+	_, err = stmt.ExecContext(ctx, namespace, iss, sub)
+	return
+}
diff --git a/userapi/storage/tables/interface.go b/userapi/storage/tables/interface.go
index 2fe9556707..d0473809ce 100644
--- a/userapi/storage/tables/interface.go
+++ b/userapi/storage/tables/interface.go
@@ -113,6 +113,12 @@ type NotificationTable interface {
 	SelectRoomCounts(ctx context.Context, txn *sql.Tx, localpart, roomID string) (total int64, highlight int64, _ error)
 }
 
+type SSOTable interface {
+	SelectLocalpartForSSO(ctx context.Context, txn *sql.Tx, namespace, iss, sub string) (string, error)
+	InsertSSO(ctx context.Context, txn *sql.Tx, namespace, iss, sub, localpart string) error
+	DeleteSSO(ctx context.Context, txn *sql.Tx, namespace, iss, sub string) error
+}
+
 type StatsTable interface {
 	UserStatistics(ctx context.Context, txn *sql.Tx) (*types.UserStatistics, *types.DatabaseEngine, error)
 	UpdateUserDailyVisits(ctx context.Context, txn *sql.Tx, startTime, lastUpdate time.Time) error

From 03cf5a5c083765a7b08146adefe243b887037c1f Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 23 May 2022 17:55:38 +0200
Subject: [PATCH 06/35] Replace ThreePID lookups with the new SSO lookups.

---
 clientapi/auth/sso/oidc_base.go | 56 +++++++++++++++++++--------------
 clientapi/auth/sso/sso.go       |  9 ++++--
 clientapi/routing/sso.go        | 23 +++++++-------
 3 files changed, 52 insertions(+), 36 deletions(-)

diff --git a/clientapi/auth/sso/oidc_base.go b/clientapi/auth/sso/oidc_base.go
index 20cd7b2cbb..4275e5733c 100644
--- a/clientapi/auth/sso/oidc_base.go
+++ b/clientapi/auth/sso/oidc_base.go
@@ -26,7 +26,7 @@ import (
 	"text/template"
 
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
-	"github.com/matrix-org/dendrite/clientapi/userutil"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
 	"github.com/tidwall/gjson"
 )
 
@@ -161,7 +161,7 @@ func (p *baseOIDCIdentityProvider) getOIDCAccessToken(ctx context.Context, req *
 	return resp.AccessToken, nil
 }
 
-func (p *baseOIDCIdentityProvider) getUserInfo(ctx context.Context, req *IdentityProviderRequest, oidcAccessToken string) (*userutil.ThirdPartyIdentifier, string, error) {
+func (p *baseOIDCIdentityProvider) getUserInfo(ctx context.Context, req *IdentityProviderRequest, oidcAccessToken string) (ssoUser *UserIdentifier, suggestedUserID string, _ error) {
 	u, err := p.UserInfoURL.Execute(map[string]interface{}{
 		"Config": req.System,
 	}, nil)
@@ -187,34 +187,44 @@ func (p *baseOIDCIdentityProvider) getUserInfo(ctx context.Context, req *Identit
 		return nil, "", err
 	}
 
-	var email string
-	var suggestedUserID string
-	switch ctype {
-	case "application/json":
-		body, err := ioutil.ReadAll(hresp.Body)
-		if err != nil {
-			return nil, "", err
-		}
+	if ctype != "application/json" {
+		return nil, "", fmt.Errorf("got unknown content type %q for user info", ctype)
+	}
 
-		emailRes := gjson.GetBytes(body, p.UserInfoEmailPath)
-		if !emailRes.Exists() {
-			return nil, "", fmt.Errorf("no email in user info response body")
-		}
-		email = emailRes.String()
+	body, err := ioutil.ReadAll(hresp.Body)
+	if err != nil {
+		return nil, "", err
+	}
 
-		// This is optional.
-		userIDRes := gjson.GetBytes(body, p.UserInfoSuggestedUserIDPath)
-		suggestedUserID = userIDRes.String()
+	issRes := gjson.GetBytes(body, "iss")
+	if !issRes.Exists() {
+		return nil, "", fmt.Errorf("no iss in user info response body")
+	}
+	iss := issRes.String()
 
-	default:
-		return nil, "", fmt.Errorf("got unknown content type %q for user info", ctype)
+	subRes := gjson.GetBytes(body, "sub")
+	if !subRes.Exists() {
+		return nil, "", fmt.Errorf("no sub in user info response body")
 	}
+	sub := subRes.String()
 
-	if email == "" {
-		return nil, "", fmt.Errorf("no email address in user info")
+	if iss == "" {
+		return nil, "", fmt.Errorf("no iss in user info")
 	}
 
-	return &userutil.ThirdPartyIdentifier{Medium: "email", Address: email}, suggestedUserID, nil
+	if sub == "" {
+		return nil, "", fmt.Errorf("no sub in user info")
+	}
+
+	// This is optional.
+	userIDRes := gjson.GetBytes(body, p.UserInfoSuggestedUserIDPath)
+	suggestedUserID = userIDRes.String()
+
+	return &UserIdentifier{
+		Namespace: uapi.OIDCNamespace,
+		Issuer:    iss,
+		Subject:   sub,
+	}, suggestedUserID, nil
 }
 
 type urlTemplate struct {
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 653863d8fc..37e3842a89 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -18,8 +18,8 @@ import (
 	"context"
 	"net/url"
 
-	"github.com/matrix-org/dendrite/clientapi/userutil"
 	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
 )
 
 type IdentityProvider interface {
@@ -37,7 +37,7 @@ type IdentityProviderRequest struct {
 
 type CallbackResult struct {
 	RedirectURL     string
-	Identifier      *userutil.ThirdPartyIdentifier
+	Identifier      *UserIdentifier
 	SuggestedUserID string
 }
 
@@ -55,3 +55,8 @@ func GetIdentityProvider(t IdentityProviderType) IdentityProvider {
 		return nil
 	}
 }
+
+type UserIdentifier struct {
+	Namespace       uapi.SSOIssuerNamespace
+	Issuer, Subject string
+}
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index e9e4e55181..17c95a8ca2 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -165,9 +165,9 @@ func SSOCallback(
 		return util.RedirectResponse(result.RedirectURL)
 	}
 
-	id, err := verifyThirdPartyUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
+	id, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
 	if err != nil {
-		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier.String()).Error("failed to find user")
+		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
 			Code: http.StatusUnauthorized,
 			JSON: jsonerror.Forbidden("ID not associated with a local account"),
@@ -176,7 +176,7 @@ func SSOCallback(
 	if id == nil {
 		// The user doesn't exist.
 		// TODO: let the user select a localpart and register an account.
-		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier.String()).Error("failed to find user")
+		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
 			Code: http.StatusNotImplemented,
 			JSON: jsonerror.Forbidden("SSO registration not implemented"),
@@ -204,7 +204,7 @@ func SSOCallback(
 type userAPIForSSO interface {
 	uapi.LoginTokenInternalAPI
 
-	QueryLocalpartForThreePID(ctx context.Context, req *uapi.QueryLocalpartForThreePIDRequest, res *uapi.QueryLocalpartForThreePIDResponse) error
+	QueryLocalpartForSSO(ctx context.Context, req *uapi.QueryLocalpartForSSORequest, res *uapi.QueryLocalpartForSSOResponse) error
 }
 
 // getProvider looks up the given provider in the
@@ -254,16 +254,17 @@ func parseNonce(s string) (redirectURL *url.URL, _ error) {
 	return u, nil
 }
 
-// verifyThirdPartyUserIdentifier resolves a ThirdPartyIdentifier to a
+// verifySSOUserIdentifier resolves an sso.UserIdentifier to a
 // UserIdentifier using the User API. Returns nil if there is no
 // associated user.
-func verifyThirdPartyUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *userutil.ThirdPartyIdentifier, serverName gomatrixserverlib.ServerName) (*userutil.UserIdentifier, error) {
-	req := &uapi.QueryLocalpartForThreePIDRequest{
-		ThreePID: id.Address,
-		Medium:   string(id.Medium),
+func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso.UserIdentifier, serverName gomatrixserverlib.ServerName) (*userutil.UserIdentifier, error) {
+	req := &uapi.QueryLocalpartForSSORequest{
+		Namespace: id.Namespace,
+		Issuer:    id.Issuer,
+		Subject:   id.Subject,
 	}
-	var res uapi.QueryLocalpartForThreePIDResponse
-	if err := userAPI.QueryLocalpartForThreePID(ctx, req, &res); err != nil {
+	var res uapi.QueryLocalpartForSSOResponse
+	if err := userAPI.QueryLocalpartForSSO(ctx, req, &res); err != nil {
 		return nil, err
 	}
 	if res.Localpart == "" {

From a6b13a703d2eee554b7c149af3b382aa73ed8e53 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Mon, 23 May 2022 18:14:45 +0200
Subject: [PATCH 07/35] Add automatic registration of SSO accounts.

---
 clientapi/routing/sso.go | 73 ++++++++++++++++++++++++++++++----------
 1 file changed, 55 insertions(+), 18 deletions(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 17c95a8ca2..d1b224fbed 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -165,7 +165,7 @@ func SSOCallback(
 		return util.RedirectResponse(result.RedirectURL)
 	}
 
-	id, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
+	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
@@ -173,17 +173,18 @@ func SSOCallback(
 			JSON: jsonerror.Forbidden("ID not associated with a local account"),
 		}
 	}
-	if id == nil {
+	if localpart == "" {
 		// The user doesn't exist.
-		// TODO: let the user select a localpart and register an account.
-		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
-		return util.JSONResponse{
-			Code: http.StatusNotImplemented,
-			JSON: jsonerror.Forbidden("SSO registration not implemented"),
+		// TODO: let the user select the local part, and whether to associate email addresses.
+		localpart = result.SuggestedUserID
+		ok, resp := registerSSOAccount(ctx, userAPI, result.Identifier, localpart)
+		if !ok {
+			util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).WithField("localpart", localpart).Error("failed to create account")
+			return resp
 		}
 	}
 
-	token, err := createLoginToken(ctx, userAPI, id)
+	token, err := createLoginToken(ctx, userAPI, userutil.MakeUserID(localpart, cfg.Matrix.ServerName))
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).Errorf("PerformLoginTokenCreation failed")
 		return jsonerror.InternalServerError()
@@ -204,6 +205,8 @@ func SSOCallback(
 type userAPIForSSO interface {
 	uapi.LoginTokenInternalAPI
 
+	PerformAccountCreation(ctx context.Context, req *uapi.PerformAccountCreationRequest, res *uapi.PerformAccountCreationResponse) error
+	PerformSaveSSOAssociation(ctx context.Context, req *uapi.PerformSaveSSOAssociationRequest, res *struct{}) error
 	QueryLocalpartForSSO(ctx context.Context, req *uapi.QueryLocalpartForSSORequest, res *uapi.QueryLocalpartForSSOResponse) error
 }
 
@@ -254,10 +257,10 @@ func parseNonce(s string) (redirectURL *url.URL, _ error) {
 	return u, nil
 }
 
-// verifySSOUserIdentifier resolves an sso.UserIdentifier to a
-// UserIdentifier using the User API. Returns nil if there is no
-// associated user.
-func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso.UserIdentifier, serverName gomatrixserverlib.ServerName) (*userutil.UserIdentifier, error) {
+// verifySSOUserIdentifier resolves an sso.UserIdentifier to a local
+// part using the User API. Returns empty if there is no associated
+// user.
+func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso.UserIdentifier, serverName gomatrixserverlib.ServerName) (localpart string, _ error) {
 	req := &uapi.QueryLocalpartForSSORequest{
 		Namespace: id.Namespace,
 		Issuer:    id.Issuer,
@@ -265,17 +268,51 @@ func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso
 	}
 	var res uapi.QueryLocalpartForSSOResponse
 	if err := userAPI.QueryLocalpartForSSO(ctx, req, &res); err != nil {
-		return nil, err
+		return "", err
 	}
-	if res.Localpart == "" {
-		return nil, nil
+	return res.Localpart, nil
+}
+
+func registerSSOAccount(ctx context.Context, userAPI userAPIForSSO, ssoID *sso.UserIdentifier, localpart string) (bool, util.JSONResponse) {
+	var accRes uapi.PerformAccountCreationResponse
+	err := userAPI.PerformAccountCreation(ctx, &uapi.PerformAccountCreationRequest{
+		Localpart:   localpart,
+		AccountType: uapi.AccountTypeUser,
+		OnConflict:  uapi.ConflictAbort,
+	}, &accRes)
+	if err != nil {
+		if _, ok := err.(*uapi.ErrorConflict); ok {
+			return false, util.JSONResponse{
+				Code: http.StatusBadRequest,
+				JSON: jsonerror.UserInUse("Desired user ID is already taken."),
+			}
+		}
+		return false, util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: jsonerror.Unknown("failed to create account: " + err.Error()),
+		}
+	}
+
+	amtRegUsers.Inc()
+
+	err = userAPI.PerformSaveSSOAssociation(ctx, &uapi.PerformSaveSSOAssociationRequest{
+		Namespace: ssoID.Namespace,
+		Issuer:    ssoID.Issuer,
+		Subject:   ssoID.Subject,
+		Localpart: localpart,
+	}, &struct{}{})
+	if err != nil {
+		return false, util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: jsonerror.Unknown("failed to associate SSO credentials with account: " + err.Error()),
+		}
 	}
 
-	return &userutil.UserIdentifier{UserID: userutil.MakeUserID(res.Localpart, serverName)}, nil
+	return true, util.JSONResponse{}
 }
 
-func createLoginToken(ctx context.Context, userAPI userAPIForSSO, id *userutil.UserIdentifier) (*uapi.LoginTokenMetadata, error) {
-	req := uapi.PerformLoginTokenCreationRequest{Data: uapi.LoginTokenData{UserID: id.UserID}}
+func createLoginToken(ctx context.Context, userAPI userAPIForSSO, userID string) (*uapi.LoginTokenMetadata, error) {
+	req := uapi.PerformLoginTokenCreationRequest{Data: uapi.LoginTokenData{UserID: userID}}
 	var resp uapi.PerformLoginTokenCreationResponse
 	if err := userAPI.PerformLoginTokenCreation(ctx, &req, &resp); err != nil {
 		return nil, err

From 58233c790a6fbd3fd8eedf9f6d3881a98d4b69d9 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 25 May 2022 01:17:08 +0200
Subject: [PATCH 08/35] Split SSO into OAuth2 and OIDC. Add OIDC discovery.

GitHub implements OAuth2, but not OpenID Connect.

This means it needs more magic constants than those that can do OIDC
discovery (and where Userinfo is in OIDC-compatible.)

Fixes the HTTP client to have a timeout.
---
 clientapi/auth/sso/github.go     |  32 ++--
 clientapi/auth/sso/oauth2.go     | 221 +++++++++++++++++++++++++
 clientapi/auth/sso/oidc.go       | 159 ++++++++++++++++++
 clientapi/auth/sso/oidc_base.go  | 272 -------------------------------
 clientapi/auth/sso/sso.go        |  78 ++++++---
 clientapi/routing/login.go       |  20 ++-
 clientapi/routing/routing.go     |  16 +-
 clientapi/routing/sso.go         |  92 +++--------
 setup/config/config_clientapi.go |  39 +++--
 userapi/api/api_sso.go           |   4 +
 10 files changed, 533 insertions(+), 400 deletions(-)
 create mode 100644 clientapi/auth/sso/oauth2.go
 create mode 100644 clientapi/auth/sso/oidc.go
 delete mode 100644 clientapi/auth/sso/oidc_base.go

diff --git a/clientapi/auth/sso/github.go b/clientapi/auth/sso/github.go
index 55f5417b66..70f1a95e08 100644
--- a/clientapi/auth/sso/github.go
+++ b/clientapi/auth/sso/github.go
@@ -15,23 +15,25 @@
 package sso
 
 import (
+	"net/http"
+
 	"github.com/matrix-org/dendrite/setup/config"
 )
 
-// GitHubIdentityProvider is a GitHub-flavored identity provider.
-var GitHubIdentityProvider IdentityProvider = githubIdentityProvider{
-	baseOIDCIdentityProvider: &baseOIDCIdentityProvider{
-		AuthURL:                     mustParseURLTemplate("https://github.com/login/oauth/authorize?scope=user:email"),
-		AccessTokenURL:              mustParseURLTemplate("https://github.com/login/oauth/access_token"),
-		UserInfoURL:                 mustParseURLTemplate("https://api.github.com/user"),
-		UserInfoAccept:              "application/vnd.github.v3+json",
-		UserInfoEmailPath:           "email",
-		UserInfoSuggestedUserIDPath: "login",
-	},
-}
+func newGitHubIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) identityProvider {
+	return &oauth2IdentityProvider{
+		cfg: cfg,
+		hc:  hc,
 
-type githubIdentityProvider struct {
-	*baseOIDCIdentityProvider
-}
+		authorizationURL: "https://github.com/login/oauth/authorize",
+		accessTokenURL:   "https://github.com/login/oauth/access_token",
+		userInfoURL:      "https://api.github.com/user",
 
-func (githubIdentityProvider) DefaultBrand() string { return config.SSOBrandGitHub }
+		scopes:              []string{"user:email"},
+		responseMimeType:    "application/vnd.github.v3+json",
+		subPath:             "id",
+		emailPath:           "email",
+		displayNamePath:     "name",
+		suggestedUserIDPath: "login",
+	}
+}
diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
new file mode 100644
index 0000000000..287e187bca
--- /dev/null
+++ b/clientapi/auth/sso/oauth2.go
@@ -0,0 +1,221 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sso
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"net/url"
+	"strings"
+
+	"github.com/matrix-org/dendrite/clientapi/jsonerror"
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+	"github.com/tidwall/gjson"
+)
+
+type oauth2IdentityProvider struct {
+	cfg *config.IdentityProvider
+	hc  *http.Client
+
+	authorizationURL string
+	accessTokenURL   string
+	userInfoURL      string
+
+	scopes              []string
+	responseMimeType    string
+	issPath             string
+	subPath             string
+	emailPath           string
+	displayNamePath     string
+	suggestedUserIDPath string
+}
+
+func (p *oauth2IdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
+	u, err := resolveURL(p.authorizationURL, url.Values{
+		"client_id":     []string{p.cfg.OIDC.ClientID},
+		"response_type": []string{"code"},
+		"redirect_uri":  []string{callbackURL},
+		"scope":         []string{strings.Join(p.scopes, " ")},
+		"state":         []string{nonce},
+	})
+	if err != nil {
+		return "", err
+	}
+	return u.String(), nil
+}
+
+func (p *oauth2IdentityProvider) ProcessCallback(ctx context.Context, callbackURL, nonce string, query url.Values) (*CallbackResult, error) {
+	state := query.Get("state")
+	if state == "" {
+		return nil, jsonerror.MissingArgument("state parameter missing")
+	}
+	if state != nonce {
+		return nil, jsonerror.InvalidArgumentValue("state parameter not matching nonce")
+	}
+
+	if error := query.Get("error"); error != "" {
+		if euri := query.Get("error_uri"); euri != "" {
+			return &CallbackResult{RedirectURL: euri}, nil
+		}
+
+		desc := query.Get("error_description")
+		if desc == "" {
+			desc = error
+		}
+		switch error {
+		case "unauthorized_client", "access_denied":
+			return nil, jsonerror.Forbidden("SSO said no: " + desc)
+		default:
+			return nil, fmt.Errorf("SSO failed: %v", error)
+		}
+	}
+
+	code := query.Get("code")
+	if code == "" {
+		return nil, jsonerror.MissingArgument("code parameter missing")
+	}
+
+	at, err := p.getAccessToken(ctx, callbackURL, code)
+	if err != nil {
+		return nil, err
+	}
+
+	subject, displayName, suggestedLocalpart, err := p.getUserInfo(ctx, at)
+	if err != nil {
+		return nil, err
+	}
+
+	return &CallbackResult{
+		Identifier: &UserIdentifier{
+			Namespace: uapi.SSOIDNamespace,
+			Issuer:    p.cfg.ID,
+			Subject:   subject,
+		},
+		DisplayName:     displayName,
+		SuggestedUserID: suggestedLocalpart,
+	}, nil
+}
+
+func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL, code string) (string, error) {
+	body := url.Values{
+		"grant_type":    []string{"authorization_code"},
+		"code":          []string{code},
+		"redirect_uri":  []string{callbackURL},
+		"client_id":     []string{p.cfg.OIDC.ClientID},
+		"client_secret": []string{p.cfg.OIDC.ClientSecret},
+	}
+	hreq, err := http.NewRequestWithContext(ctx, http.MethodPost, p.accessTokenURL, strings.NewReader(body.Encode()))
+	if err != nil {
+		return "", err
+	}
+	hreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
+	hreq.Header.Set("Accept", p.responseMimeType)
+
+	hresp, err := p.hc.Do(hreq)
+	if err != nil {
+		return "", err
+	}
+	defer hresp.Body.Close()
+
+	var resp oauth2TokenResponse
+	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
+		return "", err
+	}
+
+	if resp.Error != "" {
+		desc := resp.ErrorDescription
+		if desc == "" {
+			desc = resp.Error
+		}
+		return "", fmt.Errorf("failed to retrieve OIDC access token: %s", desc)
+	}
+
+	if strings.ToLower(resp.TokenType) != "bearer" {
+		return "", fmt.Errorf("expected bearer token, got type %q", resp.TokenType)
+	}
+
+	return resp.AccessToken, nil
+}
+
+type oauth2TokenResponse struct {
+	TokenType   string `json:"token_type"`
+	AccessToken string `json:"access_token"`
+
+	Error            string `json:"error"`
+	ErrorDescription string `json:"error_description"`
+	ErrorURI         string `json:"error_uri"`
+}
+
+func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken string) (subject, displayName, suggestedLocalpart string, _ error) {
+	hreq, err := http.NewRequestWithContext(ctx, http.MethodGet, p.userInfoURL, nil)
+	if err != nil {
+		return "", "", "", err
+	}
+	hreq.Header.Set("Authorization", "token "+accessToken)
+	hreq.Header.Set("Accept", p.responseMimeType)
+
+	hresp, err := p.hc.Do(hreq)
+	if err != nil {
+		return "", "", "", err
+	}
+	defer hresp.Body.Close()
+
+	body, err := ioutil.ReadAll(hresp.Body)
+	if err != nil {
+		return "", "", "", err
+	}
+
+	if res := gjson.GetBytes(body, p.subPath); !res.Exists() {
+		return "", "", "", fmt.Errorf("no %q in user info response body", p.subPath)
+	} else {
+		subject = res.String()
+	}
+	if subject == "" {
+		return "", "", "", fmt.Errorf("empty subject in user info")
+	}
+
+	if p.suggestedUserIDPath != "" {
+		suggestedLocalpart = gjson.GetBytes(body, p.suggestedUserIDPath).String()
+	}
+
+	if p.displayNamePath != "" {
+		displayName = gjson.GetBytes(body, p.displayNamePath).String()
+	}
+
+	return
+}
+
+func resolveURL(urlString string, defaultQuery url.Values) (*url.URL, error) {
+	u, err := url.Parse(urlString)
+	if err != nil {
+		return nil, err
+	}
+
+	if defaultQuery != nil {
+		q := u.Query()
+		for k, vs := range defaultQuery {
+			if q.Get(k) == "" {
+				q[k] = vs
+			}
+		}
+		u.RawQuery = q.Encode()
+	}
+
+	return u, nil
+}
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
new file mode 100644
index 0000000000..ac9c56a57d
--- /dev/null
+++ b/clientapi/auth/sso/oidc.go
@@ -0,0 +1,159 @@
+// Copyright 2022 The Matrix.org Foundation C.I.C.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package sso
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"net/url"
+	"sync"
+	"time"
+
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+)
+
+type oidcIdentityProvider struct {
+	*oauth2IdentityProvider
+
+	disc *oidcDiscovery
+	exp  time.Time
+	mu   sync.Mutex
+}
+
+func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oidcIdentityProvider {
+	return &oidcIdentityProvider{
+		oauth2IdentityProvider: &oauth2IdentityProvider{
+			cfg: cfg,
+			hc:  hc,
+
+			scopes:              []string{"openid", "profile", "email"},
+			responseMimeType:    "application/json",
+			subPath:             "sub",
+			emailPath:           "email",
+			displayNamePath:     "name",
+			suggestedUserIDPath: "preferred_username",
+		},
+	}
+}
+
+func (p *oidcIdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
+	oauth2p, _, err := p.get(ctx)
+	if err != nil {
+		return "", err
+	}
+	return oauth2p.AuthorizationURL(ctx, callbackURL, nonce)
+}
+
+func (p *oidcIdentityProvider) ProcessCallback(ctx context.Context, callbackURL, nonce string, query url.Values) (*CallbackResult, error) {
+	oauth2p, disc, err := p.get(ctx)
+	if err != nil {
+		return nil, err
+	}
+	res, err := oauth2p.ProcessCallback(ctx, callbackURL, nonce, query)
+	if err != nil {
+		return nil, err
+	}
+
+	// OIDC has the notion of issuer URL, which will be more
+	// stable than our configuration ID.
+	res.Identifier.Namespace = uapi.OIDCNamespace
+	res.Identifier.Issuer = disc.Issuer
+
+	return res, nil
+}
+
+func (p *oidcIdentityProvider) get(ctx context.Context) (*oauth2IdentityProvider, *oidcDiscovery, error) {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+
+	now := time.Now()
+	if p.exp.Before(now) || p.disc == nil {
+		disc, err := oidcDiscover(ctx, p.cfg.OIDC.DiscoveryURL)
+		if err != nil {
+			if p.disc != nil {
+				// Prefers returning a stale entry.
+				return p.oauth2IdentityProvider, p.disc, nil
+			}
+			return nil, nil, err
+		}
+
+		p.exp = now.Add(24 * time.Hour)
+		newProvider := *p.oauth2IdentityProvider
+		newProvider.authorizationURL = disc.AuthorizationEndpoint
+		newProvider.accessTokenURL = disc.TokenEndpoint
+		newProvider.userInfoURL = disc.UserinfoEndpoint
+
+		p.oauth2IdentityProvider = &newProvider
+		p.disc = disc
+	}
+
+	return p.oauth2IdentityProvider, p.disc, nil
+}
+
+type oidcDiscovery struct {
+	Issuer                string   `json:"issuer"`
+	AuthorizationEndpoint string   `json:"authorization_endpoint"`
+	TokenEndpoint         string   `json:"token_endpoint"`
+	UserinfoEndpoint      string   `json:"userinfo_endpoint"`
+	ScopesSupported       []string `json:"scopes_supported"`
+	ClaimsSupported       []string `json:"claims_supported"`
+}
+
+func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
+	hreq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
+	if err != nil {
+		return nil, err
+	}
+	hreq.Header.Set("Accept", "application/jrd+json,application/json;q=0.9")
+
+	hresp, err := http.DefaultClient.Do(hreq)
+	if err != nil {
+		return nil, err
+	}
+	defer hresp.Body.Close()
+
+	var disc oidcDiscovery
+	if err := json.NewDecoder(hresp.Body).Decode(&disc); err != nil {
+		return nil, err
+	}
+
+	if disc.ScopesSupported != nil {
+		if !stringSliceContains(disc.ScopesSupported, "openid") {
+			return nil, fmt.Errorf("scope 'openid' is missing in %q", url)
+		}
+	}
+
+	if disc.ClaimsSupported != nil {
+		for _, claim := range []string{"iss", "sub"} {
+			if !stringSliceContains(disc.ClaimsSupported, claim) {
+				return nil, fmt.Errorf("claim %q is not supported in %q", claim, url)
+			}
+		}
+	}
+
+	return &disc, nil
+}
+
+func stringSliceContains(ss []string, s string) bool {
+	for _, s2 := range ss {
+		if s2 == s {
+			return true
+		}
+	}
+	return false
+}
diff --git a/clientapi/auth/sso/oidc_base.go b/clientapi/auth/sso/oidc_base.go
deleted file mode 100644
index 4275e5733c..0000000000
--- a/clientapi/auth/sso/oidc_base.go
+++ /dev/null
@@ -1,272 +0,0 @@
-// Copyright 2022 The Matrix.org Foundation C.I.C.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package sso
-
-import (
-	"context"
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"mime"
-	"net/http"
-	"net/url"
-	"strings"
-	"text/template"
-
-	"github.com/matrix-org/dendrite/clientapi/jsonerror"
-	uapi "github.com/matrix-org/dendrite/userapi/api"
-	"github.com/tidwall/gjson"
-)
-
-type baseOIDCIdentityProvider struct {
-	AuthURL                     *urlTemplate
-	AccessTokenURL              *urlTemplate
-	UserInfoURL                 *urlTemplate
-	UserInfoAccept              string
-	UserInfoEmailPath           string
-	UserInfoSuggestedUserIDPath string
-}
-
-func (p *baseOIDCIdentityProvider) AuthorizationURL(ctx context.Context, req *IdentityProviderRequest) (string, error) {
-	u, err := p.AuthURL.Execute(map[string]interface{}{
-		"Config":      req.System,
-		"State":       req.DendriteNonce,
-		"RedirectURI": req.CallbackURL,
-	}, url.Values{
-		"client_id":     []string{req.System.OIDC.ClientID},
-		"response_type": []string{"code"},
-		"redirect_uri":  []string{req.CallbackURL},
-		"state":         []string{req.DendriteNonce},
-	})
-	if err != nil {
-		return "", err
-	}
-	return u.String(), nil
-}
-
-func (p *baseOIDCIdentityProvider) ProcessCallback(ctx context.Context, req *IdentityProviderRequest, values url.Values) (*CallbackResult, error) {
-	state := values.Get("state")
-	if state == "" {
-		return nil, jsonerror.MissingArgument("state parameter missing")
-	}
-	if state != req.DendriteNonce {
-		return nil, jsonerror.InvalidArgumentValue("state parameter not matching nonce")
-	}
-
-	if error := values.Get("error"); error != "" {
-		if euri := values.Get("error_uri"); euri != "" {
-			return &CallbackResult{RedirectURL: euri}, nil
-		}
-
-		desc := values.Get("error_description")
-		if desc == "" {
-			desc = error
-		}
-		switch error {
-		case "unauthorized_client", "access_denied":
-			return nil, jsonerror.Forbidden("SSO said no: " + desc)
-		default:
-			return nil, fmt.Errorf("SSO failed: %v", error)
-		}
-	}
-
-	code := values.Get("code")
-	if code == "" {
-		return nil, jsonerror.MissingArgument("code parameter missing")
-	}
-
-	oidcAccessToken, err := p.getOIDCAccessToken(ctx, req, code)
-	if err != nil {
-		return nil, err
-	}
-
-	id, userID, err := p.getUserInfo(ctx, req, oidcAccessToken)
-	if err != nil {
-		return nil, err
-	}
-
-	return &CallbackResult{Identifier: id, SuggestedUserID: userID}, nil
-}
-
-func (p *baseOIDCIdentityProvider) getOIDCAccessToken(ctx context.Context, req *IdentityProviderRequest, code string) (string, error) {
-	u, err := p.AccessTokenURL.Execute(nil, nil)
-	if err != nil {
-		return "", err
-	}
-
-	body := url.Values{
-		"grant_type":   []string{"authorization_code"},
-		"code":         []string{code},
-		"redirect_uri": []string{req.CallbackURL},
-		"client_id":    []string{req.System.OIDC.ClientID},
-	}
-
-	hreq, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), strings.NewReader(body.Encode()))
-	if err != nil {
-		return "", err
-	}
-	hreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
-	hreq.Header.Set("Accept", "application/x-www-form-urlencoded")
-
-	hresp, err := http.DefaultClient.Do(hreq)
-	if err != nil {
-		return "", err
-	}
-	defer hresp.Body.Close()
-
-	ctype, _, err := mime.ParseMediaType(hresp.Header.Get("Content-Type"))
-	if err != nil {
-		return "", err
-	}
-	if ctype != "application/json" {
-		return "", fmt.Errorf("expected URL encoded response, got content type %q", ctype)
-	}
-
-	var resp struct {
-		TokenType   string `json:"token_type"`
-		AccessToken string `json:"access_token"`
-
-		Error            string `json:"error"`
-		ErrorDescription string `json:"error_description"`
-		ErrorURI         string `json:"error_uri"`
-	}
-	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
-		return "", err
-	}
-
-	if resp.Error != "" {
-		desc := resp.ErrorDescription
-		if desc == "" {
-			desc = resp.Error
-		}
-		return "", fmt.Errorf("failed to retrieve OIDC access token: %s", desc)
-	}
-
-	if strings.ToLower(resp.TokenType) != "bearer" {
-		return "", fmt.Errorf("expected bearer token, got type %q", resp.TokenType)
-	}
-
-	return resp.AccessToken, nil
-}
-
-func (p *baseOIDCIdentityProvider) getUserInfo(ctx context.Context, req *IdentityProviderRequest, oidcAccessToken string) (ssoUser *UserIdentifier, suggestedUserID string, _ error) {
-	u, err := p.UserInfoURL.Execute(map[string]interface{}{
-		"Config": req.System,
-	}, nil)
-	if err != nil {
-		return nil, "", err
-	}
-
-	hreq, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
-	if err != nil {
-		return nil, "", err
-	}
-	hreq.Header.Set("Authorization", "token "+oidcAccessToken)
-	hreq.Header.Set("Accept", p.UserInfoAccept)
-
-	hresp, err := http.DefaultClient.Do(hreq)
-	if err != nil {
-		return nil, "", err
-	}
-	defer hresp.Body.Close()
-
-	ctype, _, err := mime.ParseMediaType(hresp.Header.Get("Content-Type"))
-	if err != nil {
-		return nil, "", err
-	}
-
-	if ctype != "application/json" {
-		return nil, "", fmt.Errorf("got unknown content type %q for user info", ctype)
-	}
-
-	body, err := ioutil.ReadAll(hresp.Body)
-	if err != nil {
-		return nil, "", err
-	}
-
-	issRes := gjson.GetBytes(body, "iss")
-	if !issRes.Exists() {
-		return nil, "", fmt.Errorf("no iss in user info response body")
-	}
-	iss := issRes.String()
-
-	subRes := gjson.GetBytes(body, "sub")
-	if !subRes.Exists() {
-		return nil, "", fmt.Errorf("no sub in user info response body")
-	}
-	sub := subRes.String()
-
-	if iss == "" {
-		return nil, "", fmt.Errorf("no iss in user info")
-	}
-
-	if sub == "" {
-		return nil, "", fmt.Errorf("no sub in user info")
-	}
-
-	// This is optional.
-	userIDRes := gjson.GetBytes(body, p.UserInfoSuggestedUserIDPath)
-	suggestedUserID = userIDRes.String()
-
-	return &UserIdentifier{
-		Namespace: uapi.OIDCNamespace,
-		Issuer:    iss,
-		Subject:   sub,
-	}, suggestedUserID, nil
-}
-
-type urlTemplate struct {
-	base *template.Template
-}
-
-func parseURLTemplate(s string) (*urlTemplate, error) {
-	t, err := template.New("").Parse(s)
-	if err != nil {
-		return nil, err
-	}
-	return &urlTemplate{base: t}, nil
-}
-
-func mustParseURLTemplate(s string) *urlTemplate {
-	t, err := parseURLTemplate(s)
-	if err != nil {
-		panic(err)
-	}
-	return t
-}
-
-func (t *urlTemplate) Execute(params interface{}, defaultQuery url.Values) (*url.URL, error) {
-	var sb strings.Builder
-	err := t.base.Execute(&sb, params)
-	if err != nil {
-		return nil, err
-	}
-
-	u, err := url.Parse(sb.String())
-	if err != nil {
-		return nil, err
-	}
-
-	if defaultQuery != nil {
-		q := u.Query()
-		for k, vs := range defaultQuery {
-			if q.Get(k) == "" {
-				q[k] = vs
-			}
-		}
-		u.RawQuery = q.Encode()
-	}
-	return u, nil
-}
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 37e3842a89..5923d84910 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -16,46 +16,78 @@ package sso
 
 import (
 	"context"
+	"fmt"
+	"net/http"
 	"net/url"
+	"time"
 
 	"github.com/matrix-org/dendrite/setup/config"
 	uapi "github.com/matrix-org/dendrite/userapi/api"
 )
 
-type IdentityProvider interface {
-	DefaultBrand() string
+type Authenticator struct {
+	providers map[string]identityProvider
+}
+
+func NewAuthenticator(cfg *config.SSO) (*Authenticator, error) {
+	hc := &http.Client{
+		Timeout: 10 * time.Second,
+		Transport: &http.Transport{
+			DisableKeepAlives: true,
+			Proxy:             http.ProxyFromEnvironment,
+		},
+	}
+
+	a := &Authenticator{
+		providers: make(map[string]identityProvider, len(cfg.Providers)),
+	}
+	for _, pcfg := range cfg.Providers {
+		typ := pcfg.Type
+		if typ == "" {
+			typ = config.IdentityProviderType(pcfg.ID)
+		}
 
-	AuthorizationURL(context.Context, *IdentityProviderRequest) (string, error)
-	ProcessCallback(context.Context, *IdentityProviderRequest, url.Values) (*CallbackResult, error)
+		switch typ {
+		case config.SSOTypeOIDC:
+			a.providers[pcfg.ID] = newOIDCIdentityProvider(&pcfg, hc)
+		case config.SSOTypeGitHub:
+			a.providers[pcfg.ID] = newGitHubIdentityProvider(&pcfg, hc)
+		default:
+			return nil, fmt.Errorf("unknown SSO provider type: %s", typ)
+		}
+	}
+
+	return a, nil
 }
 
-type IdentityProviderRequest struct {
-	System        *config.IdentityProvider
-	CallbackURL   string
-	DendriteNonce string
+func (auth *Authenticator) AuthorizationURL(ctx context.Context, providerID, callbackURL, nonce string) (string, error) {
+	p := auth.providers[providerID]
+	if p == nil {
+		return "", fmt.Errorf("unknown identity provider: %s", providerID)
+	}
+	return p.AuthorizationURL(ctx, callbackURL, nonce)
+}
+
+func (auth *Authenticator) ProcessCallback(ctx context.Context, providerID, callbackURL, nonce string, query url.Values) (*CallbackResult, error) {
+	p := auth.providers[providerID]
+	if p == nil {
+		return nil, fmt.Errorf("unknown identity provider: %s", providerID)
+	}
+	return p.ProcessCallback(ctx, callbackURL, nonce, query)
+}
+
+type identityProvider interface {
+	AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error)
+	ProcessCallback(ctx context.Context, callbackURL, nonce string, query url.Values) (*CallbackResult, error)
 }
 
 type CallbackResult struct {
 	RedirectURL     string
 	Identifier      *UserIdentifier
+	DisplayName     string
 	SuggestedUserID string
 }
 
-type IdentityProviderType string
-
-const (
-	TypeGitHub IdentityProviderType = config.SSOBrandGitHub
-)
-
-func GetIdentityProvider(t IdentityProviderType) IdentityProvider {
-	switch t {
-	case TypeGitHub:
-		return GitHubIdentityProvider
-	default:
-		return nil
-	}
-}
-
 type UserIdentifier struct {
 	Namespace       uapi.SSOIssuerNamespace
 	Issuer, Subject string
diff --git a/clientapi/routing/login.go b/clientapi/routing/login.go
index ad4aca29cb..f0600ceb18 100644
--- a/clientapi/routing/login.go
+++ b/clientapi/routing/login.go
@@ -20,7 +20,6 @@ import (
 
 	"github.com/matrix-org/dendrite/clientapi/auth"
 	"github.com/matrix-org/dendrite/clientapi/auth/authtypes"
-	"github.com/matrix-org/dendrite/clientapi/auth/sso"
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/clientapi/userutil"
 	"github.com/matrix-org/dendrite/setup/config"
@@ -46,10 +45,10 @@ type stage struct {
 }
 
 type identityProvider struct {
-	ID    string `json:"id"`
-	Name  string `json:"name"`
-	Brand string `json:"brand,omitempty"`
-	Icon  string `json:"icon,omitempty"`
+	ID    string          `json:"id"`
+	Name  string          `json:"name"`
+	Brand config.SSOBrand `json:"brand,omitempty"`
+	Icon  string          `json:"icon,omitempty"`
 }
 
 func passwordLogin() []stage {
@@ -69,11 +68,14 @@ func ssoLogin(cfg *config.ClientAPI) []stage {
 		if brand == "" {
 			typ := idp.Type
 			if typ == "" {
-				typ = idp.ID
+				typ = config.IdentityProviderType(idp.ID)
 			}
-			idpType := sso.GetIdentityProvider(sso.IdentityProviderType(typ))
-			if idpType != nil {
-				brand = idpType.DefaultBrand()
+			switch typ {
+			case config.SSOTypeGitHub:
+				brand = config.SSOBrandGitHub
+
+			default:
+				brand = config.SSOBrand(idp.ID)
 			}
 		}
 		idps = append(idps, identityProvider{
diff --git a/clientapi/routing/routing.go b/clientapi/routing/routing.go
index a833e5217a..ebc7003d78 100644
--- a/clientapi/routing/routing.go
+++ b/clientapi/routing/routing.go
@@ -23,6 +23,7 @@ import (
 	appserviceAPI "github.com/matrix-org/dendrite/appservice/api"
 	"github.com/matrix-org/dendrite/clientapi/api"
 	"github.com/matrix-org/dendrite/clientapi/auth"
+	"github.com/matrix-org/dendrite/clientapi/auth/sso"
 	clientutil "github.com/matrix-org/dendrite/clientapi/httputil"
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/clientapi/producers"
@@ -67,6 +68,15 @@ func Setup(
 	rateLimits := httputil.NewRateLimits(&cfg.RateLimiting)
 	userInteractiveAuth := auth.NewUserInteractive(userAPI, cfg)
 
+	var ssoAuthenticator *sso.Authenticator
+	if cfg.Login.SSO.Enabled {
+		var err error
+		ssoAuthenticator, err = sso.NewAuthenticator(&cfg.Login.SSO)
+		if err != nil {
+			logrus.WithError(err).Fatal("failed to create SSO authenticator")
+		}
+	}
+
 	unstableFeatures := map[string]bool{
 		"org.matrix.e2e_cross_signing": true,
 	}
@@ -565,20 +575,20 @@ func Setup(
 
 	v3mux.Handle("/login/sso/callback",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
-			return SSOCallback(req, userAPI, cfg)
+			return SSOCallback(req, userAPI, ssoAuthenticator, cfg.Matrix.ServerName)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
 	v3mux.Handle("/login/sso/redirect",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
-			return SSORedirect(req, "", cfg)
+			return SSORedirect(req, "", ssoAuthenticator)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
 	v3mux.Handle("/login/sso/redirect/{idpID}",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
 			vars := mux.Vars(req)
-			return SSORedirect(req, vars["idpID"], cfg)
+			return SSORedirect(req, vars["idpID"], ssoAuthenticator)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index d1b224fbed..6e2e1d9674 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -25,7 +25,6 @@ import (
 	"github.com/matrix-org/dendrite/clientapi/auth/sso"
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/clientapi/userutil"
-	"github.com/matrix-org/dendrite/setup/config"
 	uapi "github.com/matrix-org/dendrite/userapi/api"
 	"github.com/matrix-org/gomatrixserverlib"
 	"github.com/matrix-org/util"
@@ -36,11 +35,11 @@ import (
 func SSORedirect(
 	req *http.Request,
 	idpID string,
-	cfg *config.ClientAPI,
+	auth *sso.Authenticator,
 ) util.JSONResponse {
-	if !cfg.Login.SSO.Enabled {
+	if auth == nil {
 		return util.JSONResponse{
-			Code: http.StatusNotImplemented,
+			Code: http.StatusNotFound,
 			JSON: jsonerror.NotFound("authentication method disabled"),
 		}
 	}
@@ -60,28 +59,9 @@ func SSORedirect(
 		}
 	}
 
-	if idpID == "" {
-		// Check configuration if the client didn't provide an ID.
-		idpID = cfg.Login.SSO.DefaultProviderID
-	}
-	if idpID == "" && len(cfg.Login.SSO.Providers) > 0 {
-		// Fall back to the first provider. If there are no providers, getProvider("") will fail.
-		idpID = cfg.Login.SSO.Providers[0].ID
-	}
-	idpCfg, idpType := getProvider(cfg, idpID)
-	if idpType == nil {
-		return util.JSONResponse{
-			Code: http.StatusBadRequest,
-			JSON: jsonerror.InvalidArgumentValue("unknown identity provider"),
-		}
-	}
-
-	idpReq := &sso.IdentityProviderRequest{
-		System:        idpCfg,
-		CallbackURL:   req.URL.ResolveReference(&url.URL{Path: "../callback", RawQuery: url.Values{"provider": []string{idpID}}.Encode()}).String(),
-		DendriteNonce: formatNonce(redirectURL),
-	}
-	u, err := idpType.AuthorizationURL(req.Context(), idpReq)
+	callbackURL := req.URL.ResolveReference(&url.URL{Path: "../callback", RawQuery: url.Values{"provider": []string{idpID}}.Encode()})
+	nonce := formatNonce(redirectURL)
+	u, err := auth.AuthorizationURL(req.Context(), idpID, callbackURL.String(), nonce)
 	if err != nil {
 		return util.JSONResponse{
 			Code: http.StatusInternalServerError,
@@ -92,7 +72,7 @@ func SSORedirect(
 	resp := util.RedirectResponse(u)
 	resp.Headers["Set-Cookie"] = (&http.Cookie{
 		Name:     "oidc_nonce",
-		Value:    idpReq.DendriteNonce,
+		Value:    nonce,
 		Expires:  time.Now().Add(10 * time.Minute),
 		Secure:   true,
 		SameSite: http.SameSiteStrictMode,
@@ -105,8 +85,16 @@ func SSORedirect(
 func SSOCallback(
 	req *http.Request,
 	userAPI userAPIForSSO,
-	cfg *config.ClientAPI,
+	auth *sso.Authenticator,
+	serverName gomatrixserverlib.ServerName,
 ) util.JSONResponse {
+	if auth == nil {
+		return util.JSONResponse{
+			Code: http.StatusNotFound,
+			JSON: jsonerror.NotFound("authentication method disabled"),
+		}
+	}
+
 	ctx := req.Context()
 
 	query := req.URL.Query()
@@ -117,13 +105,6 @@ func SSOCallback(
 			JSON: jsonerror.MissingArgument("provider parameter missing"),
 		}
 	}
-	idpCfg, idpType := getProvider(cfg, idpID)
-	if idpType == nil {
-		return util.JSONResponse{
-			Code: http.StatusBadRequest,
-			JSON: jsonerror.InvalidArgumentValue("unknown identity provider"),
-		}
-	}
 
 	nonce, err := req.Cookie("oidc_nonce")
 	if err != nil {
@@ -140,19 +121,15 @@ func SSOCallback(
 		}
 	}
 
-	idpReq := &sso.IdentityProviderRequest{
-		System: idpCfg,
-		CallbackURL: (&url.URL{
-			Scheme: req.URL.Scheme,
-			Host:   req.URL.Host,
-			Path:   req.URL.Path,
-			RawQuery: url.Values{
-				"provider": []string{idpID},
-			}.Encode(),
-		}).String(),
-		DendriteNonce: nonce.Value,
+	callbackURL := &url.URL{
+		Scheme: req.URL.Scheme,
+		Host:   req.URL.Host,
+		Path:   req.URL.Path,
+		RawQuery: url.Values{
+			"provider": []string{idpID},
+		}.Encode(),
 	}
-	result, err := idpType.ProcessCallback(ctx, idpReq, query)
+	result, err := auth.ProcessCallback(ctx, idpID, callbackURL.String(), nonce.Value, query)
 	if err != nil {
 		return util.JSONResponse{
 			Code: http.StatusInternalServerError,
@@ -165,7 +142,7 @@ func SSOCallback(
 		return util.RedirectResponse(result.RedirectURL)
 	}
 
-	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, cfg.Matrix.ServerName)
+	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, serverName)
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
@@ -184,7 +161,7 @@ func SSOCallback(
 		}
 	}
 
-	token, err := createLoginToken(ctx, userAPI, userutil.MakeUserID(localpart, cfg.Matrix.ServerName))
+	token, err := createLoginToken(ctx, userAPI, userutil.MakeUserID(localpart, serverName))
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).Errorf("PerformLoginTokenCreation failed")
 		return jsonerror.InternalServerError()
@@ -210,23 +187,6 @@ type userAPIForSSO interface {
 	QueryLocalpartForSSO(ctx context.Context, req *uapi.QueryLocalpartForSSORequest, res *uapi.QueryLocalpartForSSOResponse) error
 }
 
-// getProvider looks up the given provider in the
-// configuration. Returns nil if it wasn't found or was of unknown
-// type.
-func getProvider(cfg *config.ClientAPI, id string) (*config.IdentityProvider, sso.IdentityProvider) {
-	for _, idp := range cfg.Login.SSO.Providers {
-		if idp.ID == id {
-			switch sso.IdentityProviderType(id) {
-			case sso.TypeGitHub:
-				return &idp, sso.GitHubIdentityProvider
-			default:
-				return nil, nil
-			}
-		}
-	}
-	return nil, nil
-}
-
 // formatNonce creates a random nonce that also contains the URL.
 func formatNonce(redirectURL string) string {
 	return util.RandomString(16) + "." + base64.RawURLEncoding.EncodeToString([]byte(redirectURL))
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 4f529dd8eb..2106c341c9 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -161,7 +161,7 @@ type IdentityProvider struct {
 
 	// Brand is a hint on how to display the IdP to the user. If this is empty, a default
 	// based on the type is used.
-	Brand string `yaml:"brand"`
+	Brand SSOBrand `yaml:"brand"`
 
 	// Icon is an MXC URI describing how to display the IdP to the user. Prefer using `brand`.
 	Icon string `yaml:"icon"`
@@ -169,18 +169,19 @@ type IdentityProvider struct {
 	// Type describes how this provider is implemented. It must match "github". If this is
 	// empty, the ID is used, which means there is a weak expectation that ID is also a
 	// valid type, unless you have a complicated setup.
-	Type string `yaml:"type"`
+	Type IdentityProviderType `yaml:"type"`
 
 	// OIDC contains settings for providers based on OpenID Connect (OAuth 2).
 	OIDC struct {
 		ClientID     string `yaml:"client_id"`
 		ClientSecret string `yaml:"client_secret"`
+		DiscoveryURL string `yaml:"discovery_url"`
 	} `yaml:"oidc"`
 }
 
 func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 	checkNotEmpty(configErrs, "client_api.sso.providers.id", idp.ID)
-	if !checkIdentityProviderBrand(idp.ID) {
+	if !checkIdentityProviderBrand(SSOBrand(idp.ID)) {
 		configErrs.Add(fmt.Sprintf("unrecognized ID config key %q: %s", "client_api.sso.providers", idp.ID))
 	}
 	checkNotEmpty(configErrs, "client_api.sso.providers.name", idp.Name)
@@ -192,11 +193,16 @@ func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 	}
 	typ := idp.Type
 	if idp.Type == "" {
-		typ = idp.ID
+		typ = IdentityProviderType(idp.ID)
 	}
 
 	switch typ {
-	case "github":
+	case SSOTypeOIDC:
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.discovery_url", idp.OIDC.DiscoveryURL)
+
+	case SSOTypeGitHub:
 		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
 		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
 
@@ -206,7 +212,7 @@ func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 }
 
 // See https://github.com/matrix-org/matrix-doc/blob/old_master/informal/idp-brands.md.
-func checkIdentityProviderBrand(s string) bool {
+func checkIdentityProviderBrand(s SSOBrand) bool {
 	switch s {
 	case SSOBrandApple, SSOBrandFacebook, SSOBrandGitHub, SSOBrandGitLab, SSOBrandGoogle, SSOBrandTwitter:
 		return true
@@ -215,13 +221,22 @@ func checkIdentityProviderBrand(s string) bool {
 	}
 }
 
+type SSOBrand string
+
+const (
+	SSOBrandApple    SSOBrand = "apple"
+	SSOBrandFacebook SSOBrand = "facebook"
+	SSOBrandGitHub   SSOBrand = "github"
+	SSOBrandGitLab   SSOBrand = "gitlab"
+	SSOBrandGoogle   SSOBrand = "google"
+	SSOBrandTwitter  SSOBrand = "twitter"
+)
+
+type IdentityProviderType string
+
 const (
-	SSOBrandApple    = "apple"
-	SSOBrandFacebook = "facebook"
-	SSOBrandGitHub   = "github"
-	SSOBrandGitLab   = "gitlab"
-	SSOBrandGoogle   = "google"
-	SSOBrandTwitter  = "twitter"
+	SSOTypeOIDC   IdentityProviderType = "oidc"
+	SSOTypeGitHub IdentityProviderType = "github"
 )
 
 type TURN struct {
diff --git a/userapi/api/api_sso.go b/userapi/api/api_sso.go
index 56a3686b97..58204d8cbe 100644
--- a/userapi/api/api_sso.go
+++ b/userapi/api/api_sso.go
@@ -47,6 +47,10 @@ type SSOIssuerNamespace string
 const (
 	UnknownNamespace SSOIssuerNamespace = ""
 
+	// SSOIDNamespace indicates the issuer is an ID key matching a
+	// Dendrite SSO provider configuration.
+	SSOIDNamespace SSOIssuerNamespace = "sso"
+
 	// OIDCNamespace indicates the issuer is a full URL, as defined in
 	// https://openid.net/specs/openid-connect-core-1_0.html#Terminology.
 	OIDCNamespace SSOIssuerNamespace = "oidc"

From 73e83c2b514e0f41395c93c3fd2c04187cc1f27d Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 25 May 2022 18:32:03 +0200
Subject: [PATCH 09/35] Fix SSO table initialization.

---
 userapi/storage/postgres/storage.go | 5 +++++
 userapi/storage/sqlite3/storage.go  | 5 +++++
 2 files changed, 10 insertions(+)

diff --git a/userapi/storage/postgres/storage.go b/userapi/storage/postgres/storage.go
index b9afb5a56b..27efc01db0 100644
--- a/userapi/storage/postgres/storage.go
+++ b/userapi/storage/postgres/storage.go
@@ -94,6 +94,10 @@ func NewDatabase(base *base.BaseDendrite, dbProperties *config.DatabaseOptions,
 	if err != nil {
 		return nil, fmt.Errorf("NewPostgresNotificationTable: %w", err)
 	}
+	ssoTable, err := NewPostgresSSOTable(db)
+	if err != nil {
+		return nil, fmt.Errorf("NewPostgresSSOTable: %w", err)
+	}
 	statsTable, err := NewPostgresStatsTable(db, serverName)
 	if err != nil {
 		return nil, fmt.Errorf("NewPostgresStatsTable: %w", err)
@@ -110,6 +114,7 @@ func NewDatabase(base *base.BaseDendrite, dbProperties *config.DatabaseOptions,
 		ThreePIDs:             threePIDTable,
 		Pushers:               pusherTable,
 		Notifications:         notificationsTable,
+		SSOs:                  ssoTable,
 		Stats:                 statsTable,
 		ServerName:            serverName,
 		DB:                    db,
diff --git a/userapi/storage/sqlite3/storage.go b/userapi/storage/sqlite3/storage.go
index a822f687d5..dc8f76e667 100644
--- a/userapi/storage/sqlite3/storage.go
+++ b/userapi/storage/sqlite3/storage.go
@@ -95,6 +95,10 @@ func NewDatabase(base *base.BaseDendrite, dbProperties *config.DatabaseOptions,
 	if err != nil {
 		return nil, fmt.Errorf("NewPostgresNotificationTable: %w", err)
 	}
+	ssoTable, err := NewSQLiteSSOTable(db)
+	if err != nil {
+		return nil, fmt.Errorf("NewSQLiteSSOTable: %w", err)
+	}
 	statsTable, err := NewSQLiteStatsTable(db, serverName)
 	if err != nil {
 		return nil, fmt.Errorf("NewSQLiteStatsTable: %w", err)
@@ -111,6 +115,7 @@ func NewDatabase(base *base.BaseDendrite, dbProperties *config.DatabaseOptions,
 		ThreePIDs:             threePIDTable,
 		Pushers:               pusherTable,
 		Notifications:         notificationsTable,
+		SSOs:                  ssoTable,
 		Stats:                 statsTable,
 		ServerName:            serverName,
 		DB:                    db,

From 6de730b2ee4b5460437a9116583298c1ba7c5871 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 25 May 2022 18:33:11 +0200
Subject: [PATCH 10/35] Fixes for SSO.

* Verbose logging.
* Cookie needs a path.
* Configurable callback URL.
* Various sanity checks.
---
 clientapi/auth/sso/oauth2.go     |  4 ++
 clientapi/auth/sso/oidc.go       | 42 ++++++++++++++++++--
 clientapi/auth/sso/sso.go        |  8 +++-
 clientapi/routing/routing.go     | 10 +++--
 clientapi/routing/sso.go         | 68 +++++++++++++++++++++++++++++---
 setup/config/config_clientapi.go |  8 ++++
 6 files changed, 126 insertions(+), 14 deletions(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index 287e187bca..b8d12b59e8 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -101,6 +101,10 @@ func (p *oauth2IdentityProvider) ProcessCallback(ctx context.Context, callbackUR
 		return nil, err
 	}
 
+	if subject == "" {
+		return nil, fmt.Errorf("no subject from SSO provider")
+	}
+
 	return &CallbackResult{
 		Identifier: &UserIdentifier{
 			Namespace: uapi.SSOIDNamespace,
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index ac9c56a57d..660816d9df 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -35,8 +35,8 @@ type oidcIdentityProvider struct {
 	mu   sync.Mutex
 }
 
-func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oidcIdentityProvider {
-	return &oidcIdentityProvider{
+func newOIDCIdentityProvider(ctx context.Context, cfg *config.IdentityProvider, hc *http.Client) (*oidcIdentityProvider, error) {
+	p := &oidcIdentityProvider{
 		oauth2IdentityProvider: &oauth2IdentityProvider{
 			cfg: cfg,
 			hc:  hc,
@@ -49,6 +49,17 @@ func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oid
 			suggestedUserIDPath: "preferred_username",
 		},
 	}
+
+	// TODO: Complement starts and waits for the "base image" without
+	// first starting httpmockserver, which means we cannot always do
+	// this sanity check.
+	if false {
+		if _, _, err := p.get(ctx); err != nil {
+			return nil, err
+		}
+	}
+
+	return p, nil
 }
 
 func (p *oidcIdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
@@ -129,7 +140,20 @@ func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
 
 	var disc oidcDiscovery
 	if err := json.NewDecoder(hresp.Body).Decode(&disc); err != nil {
-		return nil, err
+		return nil, fmt.Errorf("decoding OIDC discovery response from %q: %w", url, err)
+	}
+
+	if !validWebURL(disc.Issuer) {
+		return nil, fmt.Errorf("issuer identifier is invalid in %q", url)
+	}
+	if !validWebURL(disc.AuthorizationEndpoint) {
+		return nil, fmt.Errorf("authorization endpoint is invalid in %q", url)
+	}
+	if !validWebURL(disc.TokenEndpoint) {
+		return nil, fmt.Errorf("token endpoint is invalid in %q", url)
+	}
+	if !validWebURL(disc.UserinfoEndpoint) {
+		return nil, fmt.Errorf("userinfo endpoint is invalid in %q", url)
 	}
 
 	if disc.ScopesSupported != nil {
@@ -149,6 +173,18 @@ func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
 	return &disc, nil
 }
 
+func validWebURL(s string) bool {
+	if s == "" {
+		return false
+	}
+
+	u, err := url.Parse(s)
+	if err != nil {
+		return false
+	}
+	return u.Scheme != "" && u.Host != ""
+}
+
 func stringSliceContains(ss []string, s string) bool {
 	for _, s2 := range ss {
 		if s2 == s {
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 5923d84910..593fded3aa 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -29,7 +29,7 @@ type Authenticator struct {
 	providers map[string]identityProvider
 }
 
-func NewAuthenticator(cfg *config.SSO) (*Authenticator, error) {
+func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, error) {
 	hc := &http.Client{
 		Timeout: 10 * time.Second,
 		Transport: &http.Transport{
@@ -49,7 +49,11 @@ func NewAuthenticator(cfg *config.SSO) (*Authenticator, error) {
 
 		switch typ {
 		case config.SSOTypeOIDC:
-			a.providers[pcfg.ID] = newOIDCIdentityProvider(&pcfg, hc)
+			p, err := newOIDCIdentityProvider(ctx, &pcfg, hc)
+			if err != nil {
+				return nil, fmt.Errorf("failed to create OpenID Connect provider %q: %w", pcfg.ID, err)
+			}
+			a.providers[pcfg.ID] = p
 		case config.SSOTypeGitHub:
 			a.providers[pcfg.ID] = newGitHubIdentityProvider(&pcfg, hc)
 		default:
diff --git a/clientapi/routing/routing.go b/clientapi/routing/routing.go
index ebc7003d78..657954adbb 100644
--- a/clientapi/routing/routing.go
+++ b/clientapi/routing/routing.go
@@ -63,6 +63,8 @@ func Setup(
 	extRoomsProvider api.ExtraPublicRoomsProvider,
 	mscCfg *config.MSCs, natsClient *nats.Conn,
 ) {
+	ctx := context.Background()
+
 	prometheus.MustRegister(amtRegUsers, sendEventDuration)
 
 	rateLimits := httputil.NewRateLimits(&cfg.RateLimiting)
@@ -71,7 +73,7 @@ func Setup(
 	var ssoAuthenticator *sso.Authenticator
 	if cfg.Login.SSO.Enabled {
 		var err error
-		ssoAuthenticator, err = sso.NewAuthenticator(&cfg.Login.SSO)
+		ssoAuthenticator, err = sso.NewAuthenticator(ctx, &cfg.Login.SSO)
 		if err != nil {
 			logrus.WithError(err).Fatal("failed to create SSO authenticator")
 		}
@@ -139,7 +141,7 @@ func Setup(
 	// server notifications
 	if cfg.Matrix.ServerNotices.Enabled {
 		logrus.Info("Enabling server notices at /_synapse/admin/v1/send_server_notice")
-		serverNotificationSender, err := getSenderDevice(context.Background(), userAPI, cfg)
+		serverNotificationSender, err := getSenderDevice(ctx, userAPI, cfg)
 		if err != nil {
 			logrus.WithError(err).Fatal("unable to get account for sending sending server notices")
 		}
@@ -581,14 +583,14 @@ func Setup(
 
 	v3mux.Handle("/login/sso/redirect",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
-			return SSORedirect(req, "", ssoAuthenticator)
+			return SSORedirect(req, "", ssoAuthenticator, &cfg.Login.SSO)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
 	v3mux.Handle("/login/sso/redirect/{idpID}",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
 			vars := mux.Vars(req)
-			return SSORedirect(req, vars["idpID"], ssoAuthenticator)
+			return SSORedirect(req, vars["idpID"], ssoAuthenticator, &cfg.Login.SSO)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 6e2e1d9674..55df5c49b9 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -17,6 +17,7 @@ package routing
 import (
 	"context"
 	"encoding/base64"
+	"fmt"
 	"net/http"
 	"net/url"
 	"strings"
@@ -25,6 +26,7 @@ import (
 	"github.com/matrix-org/dendrite/clientapi/auth/sso"
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/clientapi/userutil"
+	"github.com/matrix-org/dendrite/setup/config"
 	uapi "github.com/matrix-org/dendrite/userapi/api"
 	"github.com/matrix-org/gomatrixserverlib"
 	"github.com/matrix-org/util"
@@ -36,7 +38,10 @@ func SSORedirect(
 	req *http.Request,
 	idpID string,
 	auth *sso.Authenticator,
+	cfg *config.SSO,
 ) util.JSONResponse {
+	ctx := req.Context()
+
 	if auth == nil {
 		return util.JSONResponse{
 			Code: http.StatusNotFound,
@@ -59,27 +64,71 @@ func SSORedirect(
 		}
 	}
 
-	callbackURL := req.URL.ResolveReference(&url.URL{Path: "../callback", RawQuery: url.Values{"provider": []string{idpID}}.Encode()})
+	callbackURL, err := buildCallbackURLFromRedirect(cfg, req)
+	if err != nil {
+		util.GetLogger(ctx).WithError(err).Error("Failed to build callback URL")
+		return util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: err,
+		}
+	}
+
+	callbackURL = callbackURL.ResolveReference(&url.URL{
+		RawQuery: url.Values{"provider": []string{idpID}}.Encode(),
+	})
 	nonce := formatNonce(redirectURL)
-	u, err := auth.AuthorizationURL(req.Context(), idpID, callbackURL.String(), nonce)
+	u, err := auth.AuthorizationURL(ctx, idpID, callbackURL.String(), nonce)
 	if err != nil {
+		util.GetLogger(ctx).WithError(err).Error("Failed to get SSO authorization URL")
 		return util.JSONResponse{
 			Code: http.StatusInternalServerError,
 			JSON: err,
 		}
 	}
 
+	util.GetLogger(ctx).Infof("SSO redirect to %s.", u)
+
 	resp := util.RedirectResponse(u)
 	resp.Headers["Set-Cookie"] = (&http.Cookie{
 		Name:     "oidc_nonce",
 		Value:    nonce,
+		Path:     "/",
 		Expires:  time.Now().Add(10 * time.Minute),
-		Secure:   true,
+		Secure:   callbackURL.Scheme != "http",
 		SameSite: http.SameSiteStrictMode,
 	}).String()
 	return resp
 }
 
+// buildCallbackURLFromRedirect builds a callback URL from a redirect
+// request and configuration.
+func buildCallbackURLFromRedirect(cfg *config.SSO, req *http.Request) (*url.URL, error) {
+	u := &url.URL{
+		Scheme: "https",
+		User:   req.URL.User,
+		Host:   req.Host,
+		Path:   req.URL.Path,
+	}
+	if req.TLS == nil {
+		u.Scheme = "http"
+	}
+
+	// Find the v3mux base, handling both `redirect` and
+	// `redirect/{idp}` and not hard-coding the Matrix version.
+	const redirectPath = "/login/sso/redirect"
+	i := strings.Index(u.Path, redirectPath)
+	if i < 0 {
+		return nil, fmt.Errorf("cannot find %q to replace in URL %q", redirectPath, u.Path)
+	}
+	u.Path = u.Path[:i] + "/login/sso/callback"
+
+	cu, err := url.Parse(cfg.CallbackURL)
+	if err != nil {
+		return nil, err
+	}
+	return u.ResolveReference(cu), nil
+}
+
 // SSOCallback implements /login/sso/callback.
 // https://spec.matrix.org/v1.2/client-server-api/#handling-the-callback-from-the-authentication-server
 func SSOCallback(
@@ -131,11 +180,13 @@ func SSOCallback(
 	}
 	result, err := auth.ProcessCallback(ctx, idpID, callbackURL.String(), nonce.Value, query)
 	if err != nil {
+		util.GetLogger(ctx).WithError(err).Error("Failed to process callback")
 		return util.JSONResponse{
 			Code: http.StatusInternalServerError,
 			JSON: err,
 		}
 	}
+	util.GetLogger(ctx).WithField("result", result).Info("SSO callback done")
 
 	if result.Identifier == nil {
 		// Not authenticated yet.
@@ -144,7 +195,7 @@ func SSOCallback(
 
 	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, serverName)
 	if err != nil {
-		util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).Error("failed to find user")
+		util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
 			Code: http.StatusUnauthorized,
 			JSON: jsonerror.Forbidden("ID not associated with a local account"),
@@ -153,10 +204,16 @@ func SSOCallback(
 	if localpart == "" {
 		// The user doesn't exist.
 		// TODO: let the user select the local part, and whether to associate email addresses.
+		util.GetLogger(ctx).WithField("localpart", result.SuggestedUserID).WithField("ssoIdentifier", result.Identifier).Info("SSO registering account")
 		localpart = result.SuggestedUserID
+		if localpart == "" {
+			util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Info("no suggested user ID from SSO provider")
+			localpart = result.Identifier.Subject
+		}
+
 		ok, resp := registerSSOAccount(ctx, userAPI, result.Identifier, localpart)
 		if !ok {
-			util.GetLogger(ctx).WithError(err).WithField("identifier", result.Identifier).WithField("localpart", localpart).Error("failed to create account")
+			util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).WithField("localpart", localpart).Error("failed to register account")
 			return resp
 		}
 	}
@@ -166,6 +223,7 @@ func SSOCallback(
 		util.GetLogger(ctx).WithError(err).Errorf("PerformLoginTokenCreation failed")
 		return jsonerror.InternalServerError()
 	}
+	util.GetLogger(ctx).WithField("localpart", localpart).WithField("ssoIdentifier", result.Identifier).Info("SSO created token")
 
 	rquery := finalRedirectURL.Query()
 	rquery.Set("loginToken", token.Token)
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 2106c341c9..342ad29458 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -117,6 +117,14 @@ type SSO struct {
 	// Enabled determines whether SSO should be allowed.
 	Enabled bool `yaml:"enabled"`
 
+	// CallbackURL is the absolute URL where a user agent can reach
+	// the Dendrite `/_matrix/v3/login/sso/callback` endpoint. This is
+	// used to create SSO redirect URLs passed to identity
+	// providers. If this is empty, a default is inferred from request
+	// headers. When Dendrite is running behind a proxy, this may not
+	// always be the right information.
+	CallbackURL string `yaml:"callback_url"`
+
 	// Providers list the identity providers this server is capable of confirming an
 	// identity with.
 	Providers []IdentityProvider `yaml:"providers"`

From 46b4abd4cfa5babd263c000031fa7e7d8f4644cf Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 25 May 2022 19:05:16 +0200
Subject: [PATCH 11/35] golangci-lint fixes.

---
 clientapi/auth/sso/oauth2.go     | 7 +++----
 clientapi/auth/sso/oidc.go       | 2 +-
 clientapi/routing/sso.go         | 4 ++--
 setup/config/config_clientapi.go | 6 +++---
 4 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index b8d12b59e8..d94320b5ce 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -39,7 +39,6 @@ type oauth2IdentityProvider struct {
 
 	scopes              []string
 	responseMimeType    string
-	issPath             string
 	subPath             string
 	emailPath           string
 	displayNamePath     string
@@ -79,7 +78,7 @@ func (p *oauth2IdentityProvider) ProcessCallback(ctx context.Context, callbackUR
 			desc = error
 		}
 		switch error {
-		case "unauthorized_client", "access_denied":
+		case "unauthorized_client", "access_denied": // nolint:misspell
 			return nil, jsonerror.Forbidden("SSO said no: " + desc)
 		default:
 			return nil, fmt.Errorf("SSO failed: %v", error)
@@ -135,7 +134,7 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 	if err != nil {
 		return "", err
 	}
-	defer hresp.Body.Close()
+	defer hresp.Body.Close() // nolint:errcheck
 
 	var resp oauth2TokenResponse
 	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
@@ -178,7 +177,7 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	if err != nil {
 		return "", "", "", err
 	}
-	defer hresp.Body.Close()
+	defer hresp.Body.Close() // nolint:errcheck
 
 	body, err := ioutil.ReadAll(hresp.Body)
 	if err != nil {
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index 660816d9df..d8ff07faae 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -136,7 +136,7 @@ func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
 	if err != nil {
 		return nil, err
 	}
-	defer hresp.Body.Close()
+	defer hresp.Body.Close() // nolint:errcheck
 
 	var disc oidcDiscovery
 	if err := json.NewDecoder(hresp.Body).Decode(&disc); err != nil {
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 55df5c49b9..ad977a9d7b 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -193,7 +193,7 @@ func SSOCallback(
 		return util.RedirectResponse(result.RedirectURL)
 	}
 
-	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier, serverName)
+	localpart, err := verifySSOUserIdentifier(ctx, userAPI, result.Identifier)
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Error("failed to find user")
 		return util.JSONResponse{
@@ -278,7 +278,7 @@ func parseNonce(s string) (redirectURL *url.URL, _ error) {
 // verifySSOUserIdentifier resolves an sso.UserIdentifier to a local
 // part using the User API. Returns empty if there is no associated
 // user.
-func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso.UserIdentifier, serverName gomatrixserverlib.ServerName) (localpart string, _ error) {
+func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso.UserIdentifier) (localpart string, _ error) {
 	req := &uapi.QueryLocalpartForSSORequest{
 		Namespace: id.Namespace,
 		Issuer:    id.Issuer,
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 342ad29458..868732361e 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -190,11 +190,11 @@ type IdentityProvider struct {
 func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 	checkNotEmpty(configErrs, "client_api.sso.providers.id", idp.ID)
 	if !checkIdentityProviderBrand(SSOBrand(idp.ID)) {
-		configErrs.Add(fmt.Sprintf("unrecognized ID config key %q: %s", "client_api.sso.providers", idp.ID))
+		configErrs.Add(fmt.Sprintf("unrecognised ID config key %q: %s", "client_api.sso.providers", idp.ID))
 	}
 	checkNotEmpty(configErrs, "client_api.sso.providers.name", idp.Name)
 	if idp.Brand != "" && !checkIdentityProviderBrand(idp.Brand) {
-		configErrs.Add(fmt.Sprintf("unrecognized brand in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Brand))
+		configErrs.Add(fmt.Sprintf("unrecognised brand in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Brand))
 	}
 	if idp.Icon != "" {
 		checkURL(configErrs, "client_api.sso.providers.icon", idp.Icon)
@@ -215,7 +215,7 @@ func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
 
 	default:
-		configErrs.Add(fmt.Sprintf("unrecognized type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", typ))
+		configErrs.Add(fmt.Sprintf("unrecognised type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", typ))
 	}
 }
 

From 83bac7df361482dcef2e7d31f8065a862455a06a Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 25 May 2022 19:25:32 +0200
Subject: [PATCH 12/35] Disables the SSO SyTest.

Requires a configuration change in SyTest.
---
 sytest-whitelist | 1 -
 1 file changed, 1 deletion(-)

diff --git a/sytest-whitelist b/sytest-whitelist
index 18917c1cfc..6af8d89ff0 100644
--- a/sytest-whitelist
+++ b/sytest-whitelist
@@ -257,7 +257,6 @@ Real non-joined users cannot room initalSync for non-world_readable rooms
 Push rules come down in an initial /sync
 Regular users can add and delete aliases in the default room configuration
 GET /v3/capabilities is not public
-login types include SSO
 GET /joined_rooms lists newly-created room
 /joined_rooms returns only joined rooms
 Message history can be paginated over federation

From 618e18f2599940ec03109470cfb4733a9f360a0e Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 09:58:31 +0200
Subject: [PATCH 13/35] Change cookie oidc_nonce to SameSite=None.

https://github.com/matrix-org/dendrite/issues/1297#issuecomment-1139357227
---
 clientapi/routing/sso.go | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index ad977a9d7b..cf8271abba 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -20,6 +20,7 @@ import (
 	"fmt"
 	"net/http"
 	"net/url"
+	"path"
 	"strings"
 	"time"
 
@@ -89,14 +90,20 @@ func SSORedirect(
 	util.GetLogger(ctx).Infof("SSO redirect to %s.", u)
 
 	resp := util.RedirectResponse(u)
-	resp.Headers["Set-Cookie"] = (&http.Cookie{
+	cookie := &http.Cookie{
 		Name:     "oidc_nonce",
 		Value:    nonce,
-		Path:     "/",
+		Path:     path.Dir(callbackURL.Path),
 		Expires:  time.Now().Add(10 * time.Minute),
 		Secure:   callbackURL.Scheme != "http",
-		SameSite: http.SameSiteStrictMode,
-	}).String()
+		SameSite: http.SameSiteNoneMode,
+	}
+	if !cookie.Secure {
+		// SameSite=None requires Secure, so we might as well remove
+		// it. See https://blog.chromium.org/2019/10/developers-get-ready-for-new.html.
+		cookie.SameSite = http.SameSiteDefaultMode
+	}
+	resp.Headers["Set-Cookie"] = cookie.String()
 	return resp
 }
 

From 43bac75c5f1713680be589945be8819864401a6e Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 12:31:38 +0200
Subject: [PATCH 14/35] Fix callback URL building in SSOCallback.

It ended up without scheme and host. Do what SSORedirect does instead.
---
 clientapi/routing/routing.go |  2 +-
 clientapi/routing/sso.go     | 30 +++++++++++++++++-------------
 2 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/clientapi/routing/routing.go b/clientapi/routing/routing.go
index 657954adbb..21bec3307a 100644
--- a/clientapi/routing/routing.go
+++ b/clientapi/routing/routing.go
@@ -577,7 +577,7 @@ func Setup(
 
 	v3mux.Handle("/login/sso/callback",
 		httputil.MakeExternalAPI("login", func(req *http.Request) util.JSONResponse {
-			return SSOCallback(req, userAPI, ssoAuthenticator, cfg.Matrix.ServerName)
+			return SSOCallback(req, userAPI, ssoAuthenticator, &cfg.Login.SSO, cfg.Matrix.ServerName)
 		}),
 	).Methods(http.MethodGet, http.MethodOptions)
 
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index cf8271abba..e5031b3456 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -65,7 +65,7 @@ func SSORedirect(
 		}
 	}
 
-	callbackURL, err := buildCallbackURLFromRedirect(cfg, req)
+	callbackURL, err := buildCallbackURLFromOther(cfg, req, "/login/sso/redirect")
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).Error("Failed to build callback URL")
 		return util.JSONResponse{
@@ -107,9 +107,9 @@ func SSORedirect(
 	return resp
 }
 
-// buildCallbackURLFromRedirect builds a callback URL from a redirect
+// buildCallbackURLFromOther builds a callback URL from another SSO
 // request and configuration.
-func buildCallbackURLFromRedirect(cfg *config.SSO, req *http.Request) (*url.URL, error) {
+func buildCallbackURLFromOther(cfg *config.SSO, req *http.Request, expectedPath string) (*url.URL, error) {
 	u := &url.URL{
 		Scheme: "https",
 		User:   req.URL.User,
@@ -122,10 +122,9 @@ func buildCallbackURLFromRedirect(cfg *config.SSO, req *http.Request) (*url.URL,
 
 	// Find the v3mux base, handling both `redirect` and
 	// `redirect/{idp}` and not hard-coding the Matrix version.
-	const redirectPath = "/login/sso/redirect"
-	i := strings.Index(u.Path, redirectPath)
+	i := strings.Index(u.Path, expectedPath)
 	if i < 0 {
-		return nil, fmt.Errorf("cannot find %q to replace in URL %q", redirectPath, u.Path)
+		return nil, fmt.Errorf("cannot find %q to replace in URL %q", expectedPath, u.Path)
 	}
 	u.Path = u.Path[:i] + "/login/sso/callback"
 
@@ -142,6 +141,7 @@ func SSOCallback(
 	req *http.Request,
 	userAPI userAPIForSSO,
 	auth *sso.Authenticator,
+	cfg *config.SSO,
 	serverName gomatrixserverlib.ServerName,
 ) util.JSONResponse {
 	if auth == nil {
@@ -177,14 +177,18 @@ func SSOCallback(
 		}
 	}
 
-	callbackURL := &url.URL{
-		Scheme: req.URL.Scheme,
-		Host:   req.URL.Host,
-		Path:   req.URL.Path,
-		RawQuery: url.Values{
-			"provider": []string{idpID},
-		}.Encode(),
+	callbackURL, err := buildCallbackURLFromOther(cfg, req, "/login/sso/callback")
+	if err != nil {
+		util.GetLogger(ctx).WithError(err).Error("Failed to build callback URL")
+		return util.JSONResponse{
+			Code: http.StatusInternalServerError,
+			JSON: err,
+		}
 	}
+
+	callbackURL = callbackURL.ResolveReference(&url.URL{
+		RawQuery: url.Values{"provider": []string{idpID}}.Encode(),
+	})
 	result, err := auth.ProcessCallback(ctx, idpID, callbackURL.String(), nonce.Value, query)
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).Error("Failed to process callback")

From 6663882cf2d5ccfd34fdebafbfe8c24269a8f654 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 18:07:52 +0200
Subject: [PATCH 15/35] Fix OAuth2 user info credentials and add HTTP error
 handling.

---
 clientapi/auth/sso/oauth2.go | 10 +++++++++-
 clientapi/auth/sso/oidc.go   |  4 ++++
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index d94320b5ce..4d62ce3a60 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -136,6 +136,10 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
+	if hresp.StatusCode/100 != 2 {
+		return "", fmt.Errorf("OAuth2 access token request %q failed: %d %s", p.accessTokenURL, hresp.StatusCode, hresp.Status)
+	}
+
 	var resp oauth2TokenResponse
 	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
 		return "", err
@@ -170,7 +174,7 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	if err != nil {
 		return "", "", "", err
 	}
-	hreq.Header.Set("Authorization", "token "+accessToken)
+	hreq.Header.Set("Authorization", "Bearer "+accessToken)
 	hreq.Header.Set("Accept", p.responseMimeType)
 
 	hresp, err := p.hc.Do(hreq)
@@ -179,6 +183,10 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
+	if hresp.StatusCode/100 != 2 {
+		return "", "", "", fmt.Errorf("OAuth2 user info request %q failed: %d %s", p.userInfoURL, hresp.StatusCode, hresp.Status)
+	}
+
 	body, err := ioutil.ReadAll(hresp.Body)
 	if err != nil {
 		return "", "", "", err
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index d8ff07faae..9d96c5cb66 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -138,6 +138,10 @@ func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
+	if hresp.StatusCode/100 != 2 {
+		return nil, fmt.Errorf("OIDC discovery request %q failed: %d %s", url, hresp.StatusCode, hresp.Status)
+	}
+
 	var disc oidcDiscovery
 	if err := json.NewDecoder(hresp.Body).Decode(&disc); err != nil {
 		return nil, fmt.Errorf("decoding OIDC discovery response from %q: %w", url, err)

From ac706be24228930830d8e9527cfd353fb5fce6a9 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 19:29:48 +0200
Subject: [PATCH 16/35] Improve error reporting for OAuth2 SSO requests.

---
 clientapi/auth/sso/oauth2.go | 79 +++++++++++++++++++++++++-----------
 1 file changed, 55 insertions(+), 24 deletions(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index 4d62ce3a60..cd61869386 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -26,6 +26,7 @@ import (
 	"github.com/matrix-org/dendrite/clientapi/jsonerror"
 	"github.com/matrix-org/dendrite/setup/config"
 	uapi "github.com/matrix-org/dendrite/userapi/api"
+	"github.com/matrix-org/util"
 	"github.com/tidwall/gjson"
 )
 
@@ -130,29 +131,17 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 	hreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 	hreq.Header.Set("Accept", p.responseMimeType)
 
-	hresp, err := p.hc.Do(hreq)
+	hresp, err := httpDo(ctx, p.hc, hreq)
 	if err != nil {
-		return "", err
+		return "", fmt.Errorf("access token: %w", err)
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
-	if hresp.StatusCode/100 != 2 {
-		return "", fmt.Errorf("OAuth2 access token request %q failed: %d %s", p.accessTokenURL, hresp.StatusCode, hresp.Status)
-	}
-
 	var resp oauth2TokenResponse
 	if err := json.NewDecoder(hresp.Body).Decode(&resp); err != nil {
 		return "", err
 	}
 
-	if resp.Error != "" {
-		desc := resp.ErrorDescription
-		if desc == "" {
-			desc = resp.Error
-		}
-		return "", fmt.Errorf("failed to retrieve OIDC access token: %s", desc)
-	}
-
 	if strings.ToLower(resp.TokenType) != "bearer" {
 		return "", fmt.Errorf("expected bearer token, got type %q", resp.TokenType)
 	}
@@ -163,10 +152,6 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 type oauth2TokenResponse struct {
 	TokenType   string `json:"token_type"`
 	AccessToken string `json:"access_token"`
-
-	Error            string `json:"error"`
-	ErrorDescription string `json:"error_description"`
-	ErrorURI         string `json:"error_uri"`
 }
 
 func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken string) (subject, displayName, suggestedLocalpart string, _ error) {
@@ -177,16 +162,12 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	hreq.Header.Set("Authorization", "Bearer "+accessToken)
 	hreq.Header.Set("Accept", p.responseMimeType)
 
-	hresp, err := p.hc.Do(hreq)
+	hresp, err := httpDo(ctx, p.hc, hreq)
 	if err != nil {
-		return "", "", "", err
+		return "", "", "", fmt.Errorf("user info: %w", err)
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
-	if hresp.StatusCode/100 != 2 {
-		return "", "", "", fmt.Errorf("OAuth2 user info request %q failed: %d %s", p.userInfoURL, hresp.StatusCode, hresp.Status)
-	}
-
 	body, err := ioutil.ReadAll(hresp.Body)
 	if err != nil {
 		return "", "", "", err
@@ -212,6 +193,56 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	return
 }
 
+func httpDo(ctx context.Context, hc *http.Client, req *http.Request) (*http.Response, error) {
+	resp, err := hc.Do(req)
+	if err != nil {
+		return nil, err
+	}
+
+	if resp.StatusCode/100 != 2 {
+		defer resp.Body.Close()
+
+		contentType := resp.Header.Get("Content-Type")
+		switch {
+		case strings.HasPrefix(contentType, "text/plain"):
+			bs, err := ioutil.ReadAll(resp.Body)
+			if err == nil {
+				if len(bs) > 80 {
+					bs = bs[:80]
+				}
+				util.GetLogger(ctx).WithField("url", req.URL.String()).WithField("status", resp.StatusCode).Warnf("OAuth2 HTTP request failed: %s", string(bs))
+			}
+		case strings.HasPrefix(contentType, "application/json"):
+			// https://openid.net/specs/openid-connect-core-1_0.html#TokenErrorResponse
+			var body oauth2Error
+			if err := json.NewDecoder(resp.Body).Decode(&body); err == nil {
+				util.GetLogger(ctx).WithField("url", req.URL.String()).WithField("status", resp.StatusCode).Warnf("OAuth2 HTTP request failed: %+v", &body)
+			}
+			if body.Error != "" {
+				return nil, fmt.Errorf("OAuth2 request %q failed: %s (%s)", req.URL.String(), resp.Status, body.Error)
+			}
+		}
+
+		if hdr := resp.Header.Get("WWW-Authenticate"); hdr != "" {
+			// https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError
+			if len(hdr) > 80 {
+				hdr = hdr[:80]
+			}
+			return nil, fmt.Errorf("OAuth2 request %q failed: %s (%s)", req.URL.String(), resp.Status, hdr)
+		}
+
+		return nil, fmt.Errorf("OAuth2 HTTP request %q failed: %s", req.URL.String(), resp.Status)
+	}
+
+	return resp, nil
+}
+
+type oauth2Error struct {
+	Error            string `json:"error"`
+	ErrorDescription string `json:"error_description"`
+	ErrorURI         string `json:"error_uri"`
+}
+
 func resolveURL(urlString string, defaultQuery url.Values) (*url.URL, error) {
 	u, err := url.Parse(urlString)
 	if err != nil {

From 80fa0bcb4c2edb45ef68e7162751a72226d56c3a Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 19:30:30 +0200
Subject: [PATCH 17/35] Enable SSO in CI.

---
 cmd/generate-config/main.go      | 21 +++++++++++++++++++++
 setup/config/config_clientapi.go | 12 +++++++-----
 2 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/cmd/generate-config/main.go b/cmd/generate-config/main.go
index 1c585d916e..29695d1144 100644
--- a/cmd/generate-config/main.go
+++ b/cmd/generate-config/main.go
@@ -82,6 +82,27 @@ func main() {
 	if *defaultsForCI {
 		cfg.AppServiceAPI.DisableTLSValidation = true
 		cfg.ClientAPI.RateLimiting.Enabled = false
+		cfg.ClientAPI.Login.SSO.Enabled = true
+		cfg.ClientAPI.Login.SSO.Providers = []config.IdentityProvider{
+			{
+				ID:   "github",
+				Name: "Fake GitHub",
+				OIDC: config.OIDC{
+					ClientID:     "aclientid",
+					ClientSecret: "aclientsecret",
+				},
+			},
+			{
+				ID:   "google",
+				Name: "Fake Google",
+				Type: "oidc",
+				OIDC: config.OIDC{
+					ClientID:     "aclientid",
+					ClientSecret: "aclientsecret",
+					DiscoveryURL: "https://accounts.google.com/.well-known/openid-configuration",
+				},
+			},
+		}
 		cfg.FederationAPI.DisableTLSValidation = false
 		// don't hit matrix.org when running tests!!!
 		cfg.FederationAPI.KeyPerspectives = config.KeyPerspectives{}
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 868732361e..9780a2549d 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -180,11 +180,13 @@ type IdentityProvider struct {
 	Type IdentityProviderType `yaml:"type"`
 
 	// OIDC contains settings for providers based on OpenID Connect (OAuth 2).
-	OIDC struct {
-		ClientID     string `yaml:"client_id"`
-		ClientSecret string `yaml:"client_secret"`
-		DiscoveryURL string `yaml:"discovery_url"`
-	} `yaml:"oidc"`
+	OIDC OIDC `yaml:"oidc"`
+}
+
+type OIDC struct {
+	ClientID     string `yaml:"client_id"`
+	ClientSecret string `yaml:"client_secret"`
+	DiscoveryURL string `yaml:"discovery_url"`
 }
 
 func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {

From 9292bb42c18935e478d03c7ae40619de29fcabef Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 19:31:08 +0200
Subject: [PATCH 18/35] Replace SSO discovery URL with an environment variable
 from Complement.

---
 build/scripts/ComplementLocal.Dockerfile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/build/scripts/ComplementLocal.Dockerfile b/build/scripts/ComplementLocal.Dockerfile
index a9feb4cd18..520c3ca699 100644
--- a/build/scripts/ComplementLocal.Dockerfile
+++ b/build/scripts/ComplementLocal.Dockerfile
@@ -30,7 +30,7 @@ RUN echo '\
 #!/bin/bash -eu \n\
 ./generate-keys --private-key matrix_key.pem \n\
 ./generate-keys --server $SERVER_NAME --tls-cert server.crt --tls-key server.key --tls-authority-cert /complement/ca/ca.crt --tls-authority-key /complement/ca/ca.key \n\
-./generate-config -server $SERVER_NAME --ci > dendrite.yaml \n\
+./generate-config -server $SERVER_NAME --ci | sed -e "s;https://accounts.google.com/;${FAKE_SSO_URL:-https://accounts.google.com/};" > dendrite.yaml \n\
 cp /complement/ca/ca.crt /usr/local/share/ca-certificates/ && update-ca-certificates \n\
 ./dendrite-monolith-server --really-enable-open-registration --tls-cert server.crt --tls-key server.key --config dendrite.yaml \n\
 ' > run.sh && chmod +x run.sh

From d351a4837946afbeca55484eadf0c0485f376732 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 19:37:41 +0200
Subject: [PATCH 19/35] Fix a golangci-lint issue.

---
 clientapi/auth/sso/oauth2.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index cd61869386..82abd9c6b6 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -200,7 +200,7 @@ func httpDo(ctx context.Context, hc *http.Client, req *http.Request) (*http.Resp
 	}
 
 	if resp.StatusCode/100 != 2 {
-		defer resp.Body.Close()
+		defer resp.Body.Close() // nolint:errcheck
 
 		contentType := resp.Header.Get("Content-Type")
 		switch {

From 09f0dca6aa871f942ba2f5bc3985bd603d802303 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 22:15:52 +0200
Subject: [PATCH 20/35] Refactor SSO configuration.

It makes more sense to base provider defaults on brand. Type is not
1:1 to brand.

Splits apart OIDC and OAuth2 to match actual specs.
---
 clientapi/auth/sso/oauth2.go     |  6 +-
 clientapi/auth/sso/oidc.go       | 15 +----
 clientapi/auth/sso/sso.go        |  9 +--
 cmd/generate-config/main.go      | 13 ++---
 setup/config/config_clientapi.go | 96 +++++++++++++++++++++++---------
 5 files changed, 85 insertions(+), 54 deletions(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index 82abd9c6b6..c36fa8c430 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -48,7 +48,7 @@ type oauth2IdentityProvider struct {
 
 func (p *oauth2IdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
 	u, err := resolveURL(p.authorizationURL, url.Values{
-		"client_id":     []string{p.cfg.OIDC.ClientID},
+		"client_id":     []string{p.cfg.OAuth2.ClientID},
 		"response_type": []string{"code"},
 		"redirect_uri":  []string{callbackURL},
 		"scope":         []string{strings.Join(p.scopes, " ")},
@@ -121,8 +121,8 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 		"grant_type":    []string{"authorization_code"},
 		"code":          []string{code},
 		"redirect_uri":  []string{callbackURL},
-		"client_id":     []string{p.cfg.OIDC.ClientID},
-		"client_secret": []string{p.cfg.OIDC.ClientSecret},
+		"client_id":     []string{p.cfg.OAuth2.ClientID},
+		"client_secret": []string{p.cfg.OAuth2.ClientSecret},
 	}
 	hreq, err := http.NewRequestWithContext(ctx, http.MethodPost, p.accessTokenURL, strings.NewReader(body.Encode()))
 	if err != nil {
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index 9d96c5cb66..1c5c574369 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -36,7 +36,7 @@ type oidcIdentityProvider struct {
 }
 
 func newOIDCIdentityProvider(ctx context.Context, cfg *config.IdentityProvider, hc *http.Client) (*oidcIdentityProvider, error) {
-	p := &oidcIdentityProvider{
+	return &oidcIdentityProvider{
 		oauth2IdentityProvider: &oauth2IdentityProvider{
 			cfg: cfg,
 			hc:  hc,
@@ -48,18 +48,7 @@ func newOIDCIdentityProvider(ctx context.Context, cfg *config.IdentityProvider,
 			displayNamePath:     "name",
 			suggestedUserIDPath: "preferred_username",
 		},
-	}
-
-	// TODO: Complement starts and waits for the "base image" without
-	// first starting httpmockserver, which means we cannot always do
-	// this sanity check.
-	if false {
-		if _, _, err := p.get(ctx); err != nil {
-			return nil, err
-		}
-	}
-
-	return p, nil
+	}, nil
 }
 
 func (p *oidcIdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 593fded3aa..6f3cf84d35 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -42,12 +42,9 @@ func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, err
 		providers: make(map[string]identityProvider, len(cfg.Providers)),
 	}
 	for _, pcfg := range cfg.Providers {
-		typ := pcfg.Type
-		if typ == "" {
-			typ = config.IdentityProviderType(pcfg.ID)
-		}
+		pcfg = pcfg.WithDefaults()
 
-		switch typ {
+		switch pcfg.Type {
 		case config.SSOTypeOIDC:
 			p, err := newOIDCIdentityProvider(ctx, &pcfg, hc)
 			if err != nil {
@@ -57,7 +54,7 @@ func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, err
 		case config.SSOTypeGitHub:
 			a.providers[pcfg.ID] = newGitHubIdentityProvider(&pcfg, hc)
 		default:
-			return nil, fmt.Errorf("unknown SSO provider type: %s", typ)
+			return nil, fmt.Errorf("unknown SSO provider type: %s", pcfg.Type)
 		}
 	}
 
diff --git a/cmd/generate-config/main.go b/cmd/generate-config/main.go
index 29695d1144..36f3ad95e8 100644
--- a/cmd/generate-config/main.go
+++ b/cmd/generate-config/main.go
@@ -85,20 +85,19 @@ func main() {
 		cfg.ClientAPI.Login.SSO.Enabled = true
 		cfg.ClientAPI.Login.SSO.Providers = []config.IdentityProvider{
 			{
-				ID:   "github",
-				Name: "Fake GitHub",
-				OIDC: config.OIDC{
+				Brand: "github",
+				OAuth2: config.OAuth2{
 					ClientID:     "aclientid",
 					ClientSecret: "aclientsecret",
 				},
 			},
 			{
-				ID:   "google",
-				Name: "Fake Google",
-				Type: "oidc",
-				OIDC: config.OIDC{
+				Brand: "google",
+				OAuth2: config.OAuth2{
 					ClientID:     "aclientid",
 					ClientSecret: "aclientsecret",
+				},
+				OIDC: config.OIDC{
 					DiscoveryURL: "https://accounts.google.com/.well-known/openid-configuration",
 				},
 			},
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index 9780a2549d..f7889870b2 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -138,7 +138,8 @@ func (sso *SSO) Verify(configErrs *ConfigErrors) {
 	var foundDefaultProvider bool
 	seenPIDs := make(map[string]bool, len(sso.Providers))
 	for _, p := range sso.Providers {
-		p.Verify(configErrs)
+		p = p.WithDefaults()
+		p.verifyNormalized(configErrs)
 		if p.ID == sso.DefaultProviderID {
 			foundDefaultProvider = true
 		}
@@ -158,42 +159,71 @@ func (sso *SSO) Verify(configErrs *ConfigErrors) {
 	}
 }
 
-// See https://github.com/matrix-org/matrix-doc/blob/old_master/informal/idp-brands.md.
 type IdentityProvider struct {
-	// ID is the unique identifier of this IdP. We use the brand identifiers as provider
-	// identifiers for simplicity.
+	// ID is the unique identifier of this IdP. If empty, the brand will be used.
 	ID string `yaml:"id"`
 
-	// Name is a human-friendly name of the provider.
+	// Name is a human-friendly name of the provider. If empty, a default based on
+	// the brand will be used.
 	Name string `yaml:"name"`
 
-	// Brand is a hint on how to display the IdP to the user. If this is empty, a default
-	// based on the type is used.
+	// Brand is a hint on how to display the IdP to the user.
+	//
+	// See https://github.com/matrix-org/matrix-doc/blob/old_master/informal/idp-brands.md.
 	Brand SSOBrand `yaml:"brand"`
 
 	// Icon is an MXC URI describing how to display the IdP to the user. Prefer using `brand`.
 	Icon string `yaml:"icon"`
 
-	// Type describes how this provider is implemented. It must match "github". If this is
-	// empty, the ID is used, which means there is a weak expectation that ID is also a
-	// valid type, unless you have a complicated setup.
+	// Type describes how this IdP is implemented. If this is empty, a default is chosen
+	// based on brand.
 	Type IdentityProviderType `yaml:"type"`
 
-	// OIDC contains settings for providers based on OpenID Connect (OAuth 2).
+	// OAuth2 contains settings for IdPs based on OpenID Connect and OAuth2.
+	OAuth2 OAuth2 `yaml:"oauth2"`
+
+	// OIDC contains settings for IdPs based on OpenID Connect.
 	OIDC OIDC `yaml:"oidc"`
 }
 
-type OIDC struct {
+func (idp *IdentityProvider) WithDefaults() IdentityProvider {
+	p := *idp
+	if p.ID == "" {
+		p.ID = string(p.Brand)
+	}
+	if p.OIDC.DiscoveryURL == "" {
+		p.OIDC.DiscoveryURL = oidcDefaultDiscoveryURLs[idp.Brand]
+	}
+	if p.Type == "" {
+		if p.OIDC.DiscoveryURL != "" {
+			p.Type = SSOTypeOIDC
+		} else if p.Brand == SSOBrandGitHub {
+			p.Type = SSOTypeGitHub
+		}
+	}
+	if p.Name == "" {
+		p.Name = oidcDefaultNames[p.Brand]
+	}
+
+	return p
+}
+
+type OAuth2 struct {
 	ClientID     string `yaml:"client_id"`
 	ClientSecret string `yaml:"client_secret"`
+}
+
+type OIDC struct {
 	DiscoveryURL string `yaml:"discovery_url"`
 }
 
 func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
+	p := idp.WithDefaults()
+	p.verifyNormalized(configErrs)
+}
+
+func (idp *IdentityProvider) verifyNormalized(configErrs *ConfigErrors) {
 	checkNotEmpty(configErrs, "client_api.sso.providers.id", idp.ID)
-	if !checkIdentityProviderBrand(SSOBrand(idp.ID)) {
-		configErrs.Add(fmt.Sprintf("unrecognised ID config key %q: %s", "client_api.sso.providers", idp.ID))
-	}
 	checkNotEmpty(configErrs, "client_api.sso.providers.name", idp.Name)
 	if idp.Brand != "" && !checkIdentityProviderBrand(idp.Brand) {
 		configErrs.Add(fmt.Sprintf("unrecognised brand in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Brand))
@@ -201,23 +231,19 @@ func (idp *IdentityProvider) Verify(configErrs *ConfigErrors) {
 	if idp.Icon != "" {
 		checkURL(configErrs, "client_api.sso.providers.icon", idp.Icon)
 	}
-	typ := idp.Type
-	if idp.Type == "" {
-		typ = IdentityProviderType(idp.ID)
-	}
 
-	switch typ {
+	switch idp.Type {
 	case SSOTypeOIDC:
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OAuth2.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OAuth2.ClientSecret)
 		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.discovery_url", idp.OIDC.DiscoveryURL)
 
 	case SSOTypeGitHub:
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OAuth2.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OAuth2.ClientSecret)
 
 	default:
-		configErrs.Add(fmt.Sprintf("unrecognised type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", typ))
+		configErrs.Add(fmt.Sprintf("unrecognised type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Type))
 	}
 }
 
@@ -231,6 +257,7 @@ func checkIdentityProviderBrand(s SSOBrand) bool {
 	}
 }
 
+// SSOBrand corresponds to https://github.com/matrix-org/matrix-spec-proposals/blob/old_master/informal/idp-brands.md
 type SSOBrand string
 
 const (
@@ -242,6 +269,25 @@ const (
 	SSOBrandTwitter  SSOBrand = "twitter"
 )
 
+var (
+	oidcDefaultDiscoveryURLs = map[SSOBrand]string{
+		// https://developers.facebook.com/docs/facebook-login/limited-login/token/
+		SSOBrandFacebook: "https://www.facebook.com/.well-known/openid-configuration/",
+		// https://docs.gitlab.com/ee/integration/openid_connect_provider.html
+		SSOBrandGitLab: "https://gitlab.com/.well-known/openid-configuration",
+		// https://developers.google.com/identity/protocols/oauth2/openid-connect
+		SSOBrandGoogle: "https://accounts.google.com/.well-known/openid-configuration",
+	}
+	oidcDefaultNames = map[SSOBrand]string{
+		SSOBrandApple:    "Apple",
+		SSOBrandFacebook: "Facebook",
+		SSOBrandGitHub:   "GitHub",
+		SSOBrandGitLab:   "GitLab",
+		SSOBrandGoogle:   "Google",
+		SSOBrandTwitter:  "Twitter",
+	}
+)
+
 type IdentityProviderType string
 
 const (

From f814f9bdf16b12c0c4567cb8ddf30cc125aa67e6 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 22:29:20 +0200
Subject: [PATCH 21/35] Fall back to numeric localpart if there is no suggested
 username.

Fixes https://github.com/matrix-org/dendrite/issues/2498.
---
 clientapi/routing/sso.go | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index e5031b3456..cfd7924090 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -21,6 +21,7 @@ import (
 	"net/http"
 	"net/url"
 	"path"
+	"strconv"
 	"strings"
 	"time"
 
@@ -219,7 +220,12 @@ func SSOCallback(
 		localpart = result.SuggestedUserID
 		if localpart == "" {
 			util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Info("no suggested user ID from SSO provider")
-			localpart = result.Identifier.Subject
+			var res uapi.QueryNumericLocalpartResponse
+			if err := userAPI.QueryNumericLocalpart(ctx, &res); err != nil {
+				util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Error("failed to generate numeric localpart")
+				return jsonerror.InternalServerError()
+			}
+			localpart = strconv.FormatInt(res.ID, 10)
 		}
 
 		ok, resp := registerSSOAccount(ctx, userAPI, result.Identifier, localpart)
@@ -254,6 +260,7 @@ type userAPIForSSO interface {
 	PerformAccountCreation(ctx context.Context, req *uapi.PerformAccountCreationRequest, res *uapi.PerformAccountCreationResponse) error
 	PerformSaveSSOAssociation(ctx context.Context, req *uapi.PerformSaveSSOAssociationRequest, res *struct{}) error
 	QueryLocalpartForSSO(ctx context.Context, req *uapi.QueryLocalpartForSSORequest, res *uapi.QueryLocalpartForSSOResponse) error
+	QueryNumericLocalpart(ctx context.Context, res *uapi.QueryNumericLocalpartResponse) error
 }
 
 // formatNonce creates a random nonce that also contains the URL.

From ffa527340ad79f2f897a157af3a7d3f8e763756b Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 23:00:44 +0200
Subject: [PATCH 22/35] Fix a lint error.

---
 clientapi/auth/sso/oidc.go | 2 +-
 clientapi/auth/sso/sso.go  | 2 +-
 clientapi/routing/sso.go   | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index 1c5c574369..708993badd 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -35,7 +35,7 @@ type oidcIdentityProvider struct {
 	mu   sync.Mutex
 }
 
-func newOIDCIdentityProvider(ctx context.Context, cfg *config.IdentityProvider, hc *http.Client) (*oidcIdentityProvider, error) {
+func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) (*oidcIdentityProvider, error) {
 	return &oidcIdentityProvider{
 		oauth2IdentityProvider: &oauth2IdentityProvider{
 			cfg: cfg,
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 6f3cf84d35..e97eb69a33 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -46,7 +46,7 @@ func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, err
 
 		switch pcfg.Type {
 		case config.SSOTypeOIDC:
-			p, err := newOIDCIdentityProvider(ctx, &pcfg, hc)
+			p, err := newOIDCIdentityProvider(&pcfg, hc)
 			if err != nil {
 				return nil, fmt.Errorf("failed to create OpenID Connect provider %q: %w", pcfg.ID, err)
 			}
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index cfd7924090..f2114733e4 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -219,7 +219,7 @@ func SSOCallback(
 		util.GetLogger(ctx).WithField("localpart", result.SuggestedUserID).WithField("ssoIdentifier", result.Identifier).Info("SSO registering account")
 		localpart = result.SuggestedUserID
 		if localpart == "" {
-			util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Info("no suggested user ID from SSO provider")
+			util.GetLogger(ctx).WithField("ssoIdentifier", result.Identifier).Info("no suggested user ID from SSO provider")
 			var res uapi.QueryNumericLocalpartResponse
 			if err := userAPI.QueryNumericLocalpart(ctx, &res); err != nil {
 				util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Error("failed to generate numeric localpart")

From b8844fb1e2a051972ebb3aef7a94fcda1e02f74c Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Fri, 27 May 2022 23:08:53 +0200
Subject: [PATCH 23/35] Fix a lint warning.

---
 clientapi/auth/sso/oidc.go | 4 ++--
 clientapi/auth/sso/sso.go  | 6 +-----
 2 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index 708993badd..d1e28a736e 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -35,7 +35,7 @@ type oidcIdentityProvider struct {
 	mu   sync.Mutex
 }
 
-func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) (*oidcIdentityProvider, error) {
+func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oidcIdentityProvider {
 	return &oidcIdentityProvider{
 		oauth2IdentityProvider: &oauth2IdentityProvider{
 			cfg: cfg,
@@ -48,7 +48,7 @@ func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) (*oi
 			displayNamePath:     "name",
 			suggestedUserIDPath: "preferred_username",
 		},
-	}, nil
+	}
 }
 
 func (p *oidcIdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index e97eb69a33..862da6dc98 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -46,11 +46,7 @@ func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, err
 
 		switch pcfg.Type {
 		case config.SSOTypeOIDC:
-			p, err := newOIDCIdentityProvider(&pcfg, hc)
-			if err != nil {
-				return nil, fmt.Errorf("failed to create OpenID Connect provider %q: %w", pcfg.ID, err)
-			}
-			a.providers[pcfg.ID] = p
+			a.providers[pcfg.ID] = newOIDCIdentityProvider(&pcfg, hc)
 		case config.SSOTypeGitHub:
 			a.providers[pcfg.ID] = newGitHubIdentityProvider(&pcfg, hc)
 		default:

From 210ab1eef61693cf9e0e7fece4f5e132acb5cd5f Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 8 Jun 2022 09:14:11 +0200
Subject: [PATCH 24/35] Add SSO tests.

Renames cookie oidc_nonce to sso_nonce, since it's defined in a file
that doesn't know about OIDC specifically.
---
 clientapi/auth/login_test.go      |  28 ++
 clientapi/auth/sso/oauth2_test.go | 226 +++++++++++++
 clientapi/auth/sso/oidc.go        |  16 +-
 clientapi/auth/sso/oidc_test.go   | 118 +++++++
 clientapi/auth/sso/sso.go         |  10 +-
 clientapi/auth/sso/sso_test.go    |  76 +++++
 clientapi/routing/routing.go      |   2 +-
 clientapi/routing/sso.go          |  37 ++-
 clientapi/routing/sso_test.go     | 531 ++++++++++++++++++++++++++++++
 setup/config/config_test.go       |  18 +-
 userapi/storage/storage_test.go   |  35 ++
 11 files changed, 1079 insertions(+), 18 deletions(-)
 create mode 100644 clientapi/auth/sso/oauth2_test.go
 create mode 100644 clientapi/auth/sso/oidc_test.go
 create mode 100644 clientapi/auth/sso/sso_test.go
 create mode 100644 clientapi/routing/sso_test.go

diff --git a/clientapi/auth/login_test.go b/clientapi/auth/login_test.go
index cb57e95526..ef4038a0e8 100644
--- a/clientapi/auth/login_test.go
+++ b/clientapi/auth/login_test.go
@@ -101,6 +101,34 @@ func TestLoginFromJSONReader(t *testing.T) {
 	}
 }
 
+func TestLoginFromJSONReaderTokenDisabled(t *testing.T) {
+	ctx := context.Background()
+
+	var userAPI fakeUserInternalAPI
+	cfg := &config.ClientAPI{
+		Matrix: &config.Global{
+			ServerName: serverName,
+		},
+		Login: config.Login{
+			SSO: config.SSO{
+				Enabled: false,
+			},
+		},
+	}
+	_, cleanup, err := LoginFromJSONReader(ctx, strings.NewReader(`{
+			"type": "m.login.token",
+			"token": "atoken",
+			"device_id": "adevice"
+		}`), &userAPI, &userAPI, cfg)
+	wantCode := "M_INVALID_ARGUMENT_VALUE"
+	if err == nil {
+		cleanup(ctx, nil)
+		t.Fatalf("LoginFromJSONReader err: got %+v, want code %q", err, wantCode)
+	} else if merr, ok := err.JSON.(*jsonerror.MatrixError); ok && merr.ErrCode != wantCode {
+		t.Fatalf("LoginFromJSONReader err: got %+v, want code %q", err, wantCode)
+	}
+}
+
 func TestBadLoginFromJSONReader(t *testing.T) {
 	ctx := context.Background()
 
diff --git a/clientapi/auth/sso/oauth2_test.go b/clientapi/auth/sso/oauth2_test.go
new file mode 100644
index 0000000000..f541a52368
--- /dev/null
+++ b/clientapi/auth/sso/oauth2_test.go
@@ -0,0 +1,226 @@
+package sso
+
+import (
+	"context"
+	"net/http"
+	"net/http/httptest"
+	"net/url"
+	"reflect"
+	"testing"
+
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+)
+
+func TestOAuth2IdentityProviderAuthorizationURL(t *testing.T) {
+	ctx := context.Background()
+
+	idp := &oauth2IdentityProvider{
+		cfg: &config.IdentityProvider{
+			OAuth2: config.OAuth2{
+				ClientID: "aclientid",
+			},
+		},
+		hc: http.DefaultClient,
+
+		authorizationURL: "https://oauth2.example.com/authorize",
+	}
+
+	got, err := idp.AuthorizationURL(ctx, "https://matrix.example.com/continue", "anonce")
+	if err != nil {
+		t.Fatalf("AuthorizationURL failed: %v", err)
+	}
+
+	if want := "https://oauth2.example.com/authorize?client_id=aclientid&redirect_uri=https%3A%2F%2Fmatrix.example.com%2Fcontinue&response_type=code&scope=&state=anonce"; got != want {
+		t.Errorf("AuthorizationURL: got %q, want %q", got, want)
+	}
+}
+
+func TestOAuth2IdentityProviderProcessCallback(t *testing.T) {
+	ctx := context.Background()
+
+	const callbackURL = "https://matrix.example.com/continue"
+
+	tsts := []struct {
+		Name  string
+		Query url.Values
+
+		Want         *CallbackResult
+		WantTokenReq url.Values
+	}{
+		{
+			Name: "gotEverything",
+			Query: url.Values{
+				"code":  []string{"acode"},
+				"state": []string{"anonce"},
+			},
+
+			Want: &CallbackResult{
+				Identifier: &UserIdentifier{
+					Namespace: uapi.SSOIDNamespace,
+					Issuer:    "anid",
+					Subject:   "asub",
+				},
+				DisplayName:     "aname",
+				SuggestedUserID: "auser",
+			},
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			mux := http.NewServeMux()
+			mux.HandleFunc("/token", func(w http.ResponseWriter, r *http.Request) {
+				w.Header().Set("Content-Type", "application/json")
+				w.Write([]byte(`{"access_token":"atoken", "token_type":"Bearer"}`))
+			})
+			mux.HandleFunc("/userinfo", func(w http.ResponseWriter, r *http.Request) {
+				w.Header().Set("Content-Type", "application/json")
+				w.Write([]byte(`{"sub":"asub", "name":"aname", "preferred_user":"auser"}`))
+			})
+
+			s := httptest.NewServer(mux)
+			defer s.Close()
+
+			idp := &oauth2IdentityProvider{
+				cfg: &config.IdentityProvider{
+					ID: "anid",
+					OAuth2: config.OAuth2{
+						ClientID:     "aclientid",
+						ClientSecret: "aclientsecret",
+					},
+				},
+				hc: s.Client(),
+
+				accessTokenURL: s.URL + "/token",
+				userInfoURL:    s.URL + "/userinfo",
+
+				subPath:             "sub",
+				displayNamePath:     "name",
+				suggestedUserIDPath: "preferred_user",
+			}
+
+			got, err := idp.ProcessCallback(ctx, callbackURL, "anonce", tst.Query)
+			if err != nil {
+				t.Fatalf("ProcessCallback failed: %v", err)
+			}
+
+			if !reflect.DeepEqual(got, tst.Want) {
+				t.Errorf("ProcessCallback: got %+v, want %+v", got, tst.Want)
+			}
+		})
+	}
+}
+
+func TestOAuth2IdentityProviderGetAccessToken(t *testing.T) {
+	ctx := context.Background()
+
+	const callbackURL = "https://matrix.example.com/continue"
+
+	mux := http.NewServeMux()
+	var gotReq url.Values
+	mux.HandleFunc("/token", func(w http.ResponseWriter, r *http.Request) {
+		if err := r.ParseForm(); err != nil {
+			http.Error(w, err.Error(), http.StatusInternalServerError)
+			return
+		}
+
+		gotReq = r.Form
+
+		w.Header().Set("Content-Type", "application/json")
+		w.Write([]byte(`{"access_token":"atoken", "token_type":"Bearer"}`))
+	})
+
+	s := httptest.NewServer(mux)
+	defer s.Close()
+
+	idp := &oauth2IdentityProvider{
+		cfg: &config.IdentityProvider{
+			ID: "anid",
+			OAuth2: config.OAuth2{
+				ClientID:     "aclientid",
+				ClientSecret: "aclientsecret",
+			},
+		},
+		hc: s.Client(),
+
+		accessTokenURL: s.URL + "/token",
+	}
+
+	got, err := idp.getAccessToken(ctx, callbackURL, "acode")
+	if err != nil {
+		t.Fatalf("getAccessToken failed: %v", err)
+	}
+
+	if want := "atoken"; got != want {
+		t.Errorf("getAccessToken: got %q, want %q", got, want)
+	}
+
+	wantReq := url.Values{
+		"client_id":     []string{"aclientid"},
+		"client_secret": []string{"aclientsecret"},
+		"code":          []string{"acode"},
+		"grant_type":    []string{"authorization_code"},
+		"redirect_uri":  []string{callbackURL},
+	}
+	if !reflect.DeepEqual(gotReq, wantReq) {
+		t.Errorf("getAccessToken request: got %+v, want %+v", gotReq, wantReq)
+	}
+}
+
+func TestOAuth2IdentityProviderGetUserInfo(t *testing.T) {
+	ctx := context.Background()
+
+	mux := http.NewServeMux()
+	var gotHeader http.Header
+	mux.HandleFunc("/userinfo", func(w http.ResponseWriter, r *http.Request) {
+		gotHeader = r.Header
+		w.Header().Set("Content-Type", "application/json")
+		w.Write([]byte(`{"sub":"asub", "name":"aname", "preferred_user":"auser"}`))
+	})
+
+	s := httptest.NewServer(mux)
+	defer s.Close()
+
+	idp := &oauth2IdentityProvider{
+		cfg: &config.IdentityProvider{
+			ID: "anid",
+			OAuth2: config.OAuth2{
+				ClientID:     "aclientid",
+				ClientSecret: "aclientsecret",
+			},
+		},
+		hc: s.Client(),
+
+		userInfoURL: s.URL + "/userinfo",
+
+		responseMimeType:    "application/json",
+		subPath:             "sub",
+		displayNamePath:     "name",
+		suggestedUserIDPath: "preferred_user",
+	}
+
+	gotSub, gotName, gotSuggestedUser, err := idp.getUserInfo(ctx, "atoken")
+	if err != nil {
+		t.Fatalf("getUserInfo failed: %v", err)
+	}
+
+	if want := "asub"; gotSub != want {
+		t.Errorf("getUserInfo subject: got %q, want %q", gotSub, want)
+	}
+	if want := "aname"; gotName != want {
+		t.Errorf("getUserInfo displayName: got %q, want %q", gotName, want)
+	}
+	if want := "auser"; gotSuggestedUser != want {
+		t.Errorf("getUserInfo suggestedUser: got %q, want %q", gotSuggestedUser, want)
+	}
+
+	gotHeader.Del("Accept-Encoding")
+	gotHeader.Del("User-Agent")
+	wantHeader := http.Header{
+		"Accept":        []string{"application/json"},
+		"Authorization": []string{"Bearer atoken"},
+	}
+	if !reflect.DeepEqual(gotHeader, wantHeader) {
+		t.Errorf("getUserInfo header: got %+v, want %+v", gotHeader, wantHeader)
+	}
+}
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index d1e28a736e..7d00e457ff 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -27,6 +27,18 @@ import (
 	uapi "github.com/matrix-org/dendrite/userapi/api"
 )
 
+// oidcDiscoveryMaxStaleness indicates how stale the Discovery
+// information is allowed to be. This will very rarely change, so
+// we're just making sure even a Dendrite that isn't restarting often
+// is picking this up eventually.
+const oidcDiscoveryMaxStaleness = 24 * time.Hour
+
+// An oidcIdentityProvider wraps OAuth2 with OpenID Connect Discovery.
+//
+// The SSO identifier is the "sub." A suggested UserID is grabbed from
+// "preferred_username", though this isn't commonly provided.
+//
+// See https://openid.net/specs/openid-connect-core-1_0.html and https://openid.net/specs/openid-connect-discovery-1_0.html.
 type oidcIdentityProvider struct {
 	*oauth2IdentityProvider
 
@@ -44,7 +56,7 @@ func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oid
 			scopes:              []string{"openid", "profile", "email"},
 			responseMimeType:    "application/json",
 			subPath:             "sub",
-			emailPath:           "email",
+			emailPath:           "email", // TODO: should this require email_verified?
 			displayNamePath:     "name",
 			suggestedUserIDPath: "preferred_username",
 		},
@@ -92,7 +104,7 @@ func (p *oidcIdentityProvider) get(ctx context.Context) (*oauth2IdentityProvider
 			return nil, nil, err
 		}
 
-		p.exp = now.Add(24 * time.Hour)
+		p.exp = now.Add(oidcDiscoveryMaxStaleness)
 		newProvider := *p.oauth2IdentityProvider
 		newProvider.authorizationURL = disc.AuthorizationEndpoint
 		newProvider.accessTokenURL = disc.TokenEndpoint
diff --git a/clientapi/auth/sso/oidc_test.go b/clientapi/auth/sso/oidc_test.go
new file mode 100644
index 0000000000..21205e80cc
--- /dev/null
+++ b/clientapi/auth/sso/oidc_test.go
@@ -0,0 +1,118 @@
+package sso
+
+import (
+	"context"
+	"fmt"
+	"net/http"
+	"net/http/httptest"
+	"net/url"
+	"reflect"
+	"testing"
+
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+)
+
+func TestOIDCIdentityProviderAuthorizationURL(t *testing.T) {
+	ctx := context.Background()
+
+	mux := http.NewServeMux()
+	mux.HandleFunc("/discovery", func(w http.ResponseWriter, r *http.Request) {
+		w.Header().Set("Content-Type", "application/json")
+		w.Write([]byte(`{"authorization_endpoint":"http://oidc.example.com/authorize","token_endpoint":"http://oidc.example.com/token","userinfo_endpoint":"http://oidc.example.com/userinfo","issuer":"http://oidc.example.com/"}`))
+	})
+
+	s := httptest.NewServer(mux)
+	defer s.Close()
+
+	idp := newOIDCIdentityProvider(&config.IdentityProvider{
+		OAuth2: config.OAuth2{
+			ClientID: "aclientid",
+		},
+		OIDC: config.OIDC{
+			DiscoveryURL: s.URL + "/discovery",
+		},
+	}, s.Client())
+
+	got, err := idp.AuthorizationURL(ctx, "https://matrix.example.com/continue", "anonce")
+	if err != nil {
+		t.Fatalf("AuthorizationURL failed: %v", err)
+	}
+
+	if want := "http://oidc.example.com/authorize?client_id=aclientid&redirect_uri=https%3A%2F%2Fmatrix.example.com%2Fcontinue&response_type=code&scope=openid+profile+email&state=anonce"; got != want {
+		t.Errorf("AuthorizationURL: got %q, want %q", got, want)
+	}
+}
+
+func TestOIDCIdentityProviderProcessCallback(t *testing.T) {
+	ctx := context.Background()
+
+	const callbackURL = "https://matrix.example.com/continue"
+
+	tsts := []struct {
+		Name  string
+		Query url.Values
+
+		Want         *CallbackResult
+		WantTokenReq url.Values
+	}{
+		{
+			Name: "gotEverything",
+			Query: url.Values{
+				"code":  []string{"acode"},
+				"state": []string{"anonce"},
+			},
+
+			Want: &CallbackResult{
+				Identifier: &UserIdentifier{
+					Namespace: uapi.OIDCNamespace,
+					Issuer:    "http://oidc.example.com/",
+					Subject:   "asub",
+				},
+				DisplayName:     "aname",
+				SuggestedUserID: "auser",
+			},
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			mux := http.NewServeMux()
+			var sURL string
+			mux.HandleFunc("/discovery", func(w http.ResponseWriter, r *http.Request) {
+				w.Header().Set("Content-Type", "application/json")
+				w.Write([]byte(fmt.Sprintf(`{"authorization_endpoint":"%s/authorize","token_endpoint":"%s/token","userinfo_endpoint":"%s/userinfo","issuer":"http://oidc.example.com/"}`,
+					sURL, sURL, sURL)))
+			})
+			mux.HandleFunc("/token", func(w http.ResponseWriter, r *http.Request) {
+				w.Header().Set("Content-Type", "application/json")
+				w.Write([]byte(`{"access_token":"atoken", "token_type":"Bearer"}`))
+			})
+			mux.HandleFunc("/userinfo", func(w http.ResponseWriter, r *http.Request) {
+				w.Header().Set("Content-Type", "application/json")
+				w.Write([]byte(`{"sub":"asub", "name":"aname", "preferred_username":"auser"}`))
+			})
+
+			s := httptest.NewServer(mux)
+			defer s.Close()
+
+			sURL = s.URL
+			idp := newOIDCIdentityProvider(&config.IdentityProvider{
+				OAuth2: config.OAuth2{
+					ClientID: "aclientid",
+				},
+				OIDC: config.OIDC{
+					DiscoveryURL: sURL + "/discovery",
+				},
+			}, s.Client())
+
+			got, err := idp.ProcessCallback(ctx, callbackURL, "anonce", tst.Query)
+			if err != nil {
+				t.Fatalf("ProcessCallback failed: %v", err)
+			}
+
+			if !reflect.DeepEqual(got, tst.Want) {
+				t.Errorf("ProcessCallback: got %+v, want %+v", got, tst.Want)
+			}
+		})
+	}
+}
diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 862da6dc98..90c613b37b 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -25,13 +25,19 @@ import (
 	uapi "github.com/matrix-org/dendrite/userapi/api"
 )
 
+// maxHTTPTimeout is an upper bound on an HTTP request to an SSO
+// backend. The individual request context deadlines are also honored.
+const maxHTTPTimeout = 10 * time.Second
+
+// An Authenticator keeps a set of identity providers and dispatches
+// calls to one of them, based on configured ID.
 type Authenticator struct {
 	providers map[string]identityProvider
 }
 
-func NewAuthenticator(ctx context.Context, cfg *config.SSO) (*Authenticator, error) {
+func NewAuthenticator(cfg *config.SSO) (*Authenticator, error) {
 	hc := &http.Client{
-		Timeout: 10 * time.Second,
+		Timeout: maxHTTPTimeout,
 		Transport: &http.Transport{
 			DisableKeepAlives: true,
 			Proxy:             http.ProxyFromEnvironment,
diff --git a/clientapi/auth/sso/sso_test.go b/clientapi/auth/sso/sso_test.go
new file mode 100644
index 0000000000..663e077213
--- /dev/null
+++ b/clientapi/auth/sso/sso_test.go
@@ -0,0 +1,76 @@
+package sso
+
+import (
+	"context"
+	"net/url"
+	"reflect"
+	"testing"
+
+	"github.com/matrix-org/dendrite/setup/config"
+)
+
+func TestNewAuthenticator(t *testing.T) {
+	_, err := NewAuthenticator(&config.SSO{
+		Providers: []config.IdentityProvider{
+			{
+				Type: config.SSOTypeGitHub,
+				OAuth2: config.OAuth2{
+					ClientID: "aclientid",
+				},
+			},
+			{
+				Type: config.SSOTypeOIDC,
+				OAuth2: config.OAuth2{
+					ClientID: "aclientid",
+				},
+				OIDC: config.OIDC{
+					DiscoveryURL: "http://oidc.example.com/discovery",
+				},
+			},
+		},
+	})
+	if err != nil {
+		t.Fatalf("NewAuthenticator failed: %v", err)
+	}
+}
+
+func TestAuthenticator(t *testing.T) {
+	ctx := context.Background()
+
+	var idp fakeIdentityProvider
+	a := Authenticator{
+		providers: map[string]identityProvider{
+			"fake": &idp,
+		},
+	}
+
+	t.Run("authorizationURL", func(t *testing.T) {
+		got, err := a.AuthorizationURL(ctx, "fake", "http://matrix.example.com/continue", "anonce")
+		if err != nil {
+			t.Fatalf("AuthorizationURL failed: %v", err)
+		}
+		if want := "aurl"; got != want {
+			t.Errorf("AuthorizationURL: got %q, want %q", got, want)
+		}
+	})
+
+	t.Run("processCallback", func(t *testing.T) {
+		got, err := a.ProcessCallback(ctx, "fake", "http://matrix.example.com/continue", "anonce", url.Values{})
+		if err != nil {
+			t.Fatalf("ProcessCallback failed: %v", err)
+		}
+		if want := (&CallbackResult{DisplayName: "aname"}); !reflect.DeepEqual(got, want) {
+			t.Errorf("ProcessCallback: got %+v, want %+v", got, want)
+		}
+	})
+}
+
+type fakeIdentityProvider struct{}
+
+func (idp *fakeIdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
+	return "aurl", nil
+}
+
+func (idp *fakeIdentityProvider) ProcessCallback(ctx context.Context, callbackURL, nonce string, query url.Values) (*CallbackResult, error) {
+	return &CallbackResult{DisplayName: "aname"}, nil
+}
diff --git a/clientapi/routing/routing.go b/clientapi/routing/routing.go
index 21bec3307a..82b6ef9766 100644
--- a/clientapi/routing/routing.go
+++ b/clientapi/routing/routing.go
@@ -73,7 +73,7 @@ func Setup(
 	var ssoAuthenticator *sso.Authenticator
 	if cfg.Login.SSO.Enabled {
 		var err error
-		ssoAuthenticator, err = sso.NewAuthenticator(ctx, &cfg.Login.SSO)
+		ssoAuthenticator, err = sso.NewAuthenticator(&cfg.Login.SSO)
 		if err != nil {
 			logrus.WithError(err).Fatal("failed to create SSO authenticator")
 		}
diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index f2114733e4..154b7e93d3 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -39,7 +39,7 @@ import (
 func SSORedirect(
 	req *http.Request,
 	idpID string,
-	auth *sso.Authenticator,
+	auth ssoAuthenticator,
 	cfg *config.SSO,
 ) util.JSONResponse {
 	ctx := req.Context()
@@ -58,12 +58,16 @@ func SSORedirect(
 			JSON: jsonerror.MissingArgument("redirectUrl parameter missing"),
 		}
 	}
-	_, err := url.Parse(redirectURL)
-	if err != nil {
+	if ru, err := url.Parse(redirectURL); err != nil {
 		return util.JSONResponse{
 			Code: http.StatusBadRequest,
 			JSON: jsonerror.InvalidArgumentValue("Invalid redirectURL: " + err.Error()),
 		}
+	} else if ru.Scheme == "" || ru.Host == "" || ru.Path == "" {
+		return util.JSONResponse{
+			Code: http.StatusBadRequest,
+			JSON: jsonerror.InvalidArgumentValue("Invalid redirectURL: " + redirectURL),
+		}
 	}
 
 	callbackURL, err := buildCallbackURLFromOther(cfg, req, "/login/sso/redirect")
@@ -92,7 +96,7 @@ func SSORedirect(
 
 	resp := util.RedirectResponse(u)
 	cookie := &http.Cookie{
-		Name:     "oidc_nonce",
+		Name:     "sso_nonce",
 		Value:    nonce,
 		Path:     path.Dir(callbackURL.Path),
 		Expires:  time.Now().Add(10 * time.Minute),
@@ -113,7 +117,6 @@ func SSORedirect(
 func buildCallbackURLFromOther(cfg *config.SSO, req *http.Request, expectedPath string) (*url.URL, error) {
 	u := &url.URL{
 		Scheme: "https",
-		User:   req.URL.User,
 		Host:   req.Host,
 		Path:   req.URL.Path,
 	}
@@ -141,7 +144,7 @@ func buildCallbackURLFromOther(cfg *config.SSO, req *http.Request, expectedPath
 func SSOCallback(
 	req *http.Request,
 	userAPI userAPIForSSO,
-	auth *sso.Authenticator,
+	auth ssoAuthenticator,
 	cfg *config.SSO,
 	serverName gomatrixserverlib.ServerName,
 ) util.JSONResponse {
@@ -163,7 +166,7 @@ func SSOCallback(
 		}
 	}
 
-	nonce, err := req.Cookie("oidc_nonce")
+	nonce, err := req.Cookie("sso_nonce")
 	if err != nil {
 		return util.JSONResponse{
 			Code: http.StatusBadRequest,
@@ -246,7 +249,7 @@ func SSOCallback(
 	rquery.Set("loginToken", token.Token)
 	resp := util.RedirectResponse(finalRedirectURL.ResolveReference(&url.URL{RawQuery: rquery.Encode()}).String())
 	resp.Headers["Set-Cookie"] = (&http.Cookie{
-		Name:   "oidc_nonce",
+		Name:   "sso_nonce",
 		Value:  "",
 		MaxAge: -1,
 		Secure: true,
@@ -254,6 +257,11 @@ func SSOCallback(
 	return resp
 }
 
+type ssoAuthenticator interface {
+	AuthorizationURL(ctx context.Context, providerID, callbackURL, nonce string) (string, error)
+	ProcessCallback(ctx context.Context, providerID, callbackURL, nonce string, query url.Values) (*sso.CallbackResult, error)
+}
+
 type userAPIForSSO interface {
 	uapi.LoginTokenInternalAPI
 
@@ -273,21 +281,21 @@ func formatNonce(redirectURL string) string {
 // function. The URL is not integrity protected.
 func parseNonce(s string) (redirectURL *url.URL, _ error) {
 	if s == "" {
-		return nil, jsonerror.MissingArgument("empty OIDC nonce cookie")
+		return nil, jsonerror.MissingArgument("empty SSO nonce cookie")
 	}
 
 	ss := strings.Split(s, ".")
 	if len(ss) < 2 {
-		return nil, jsonerror.InvalidArgumentValue("malformed OIDC nonce cookie")
+		return nil, jsonerror.InvalidArgumentValue("malformed SSO nonce cookie")
 	}
 
 	urlbs, err := base64.RawURLEncoding.DecodeString(ss[1])
 	if err != nil {
-		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in OIDC nonce cookie")
+		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in SSO nonce cookie")
 	}
 	u, err := url.Parse(string(urlbs))
 	if err != nil {
-		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in OIDC nonce cookie: " + err.Error())
+		return nil, jsonerror.InvalidArgumentValue("invalid redirect URL in SSO nonce cookie: " + err.Error())
 	}
 
 	return u, nil
@@ -309,6 +317,9 @@ func verifySSOUserIdentifier(ctx context.Context, userAPI userAPIForSSO, id *sso
 	return res.Localpart, nil
 }
 
+// registerSSOAccount creates an account and associates the SSO
+// identifier with it. Note that SSO login account creation doesn't
+// use the standard registration API, but happens ad-hoc.
 func registerSSOAccount(ctx context.Context, userAPI userAPIForSSO, ssoID *sso.UserIdentifier, localpart string) (bool, util.JSONResponse) {
 	var accRes uapi.PerformAccountCreationResponse
 	err := userAPI.PerformAccountCreation(ctx, &uapi.PerformAccountCreationRequest{
@@ -347,6 +358,8 @@ func registerSSOAccount(ctx context.Context, userAPI userAPIForSSO, ssoID *sso.U
 	return true, util.JSONResponse{}
 }
 
+// createLoginToken produces a new login token, valid for the given
+// user.
 func createLoginToken(ctx context.Context, userAPI userAPIForSSO, userID string) (*uapi.LoginTokenMetadata, error) {
 	req := uapi.PerformLoginTokenCreationRequest{Data: uapi.LoginTokenData{UserID: userID}}
 	var resp uapi.PerformLoginTokenCreationResponse
diff --git a/clientapi/routing/sso_test.go b/clientapi/routing/sso_test.go
new file mode 100644
index 0000000000..a26604b13b
--- /dev/null
+++ b/clientapi/routing/sso_test.go
@@ -0,0 +1,531 @@
+package routing
+
+import (
+	"context"
+	"encoding/base64"
+	"errors"
+	"net/http"
+	"net/url"
+	"regexp"
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/matrix-org/dendrite/clientapi/auth/sso"
+	"github.com/matrix-org/dendrite/setup/config"
+	uapi "github.com/matrix-org/dendrite/userapi/api"
+)
+
+func TestSSORedirect(t *testing.T) {
+	tsts := []struct {
+		Name   string
+		Req    http.Request
+		IDPID  string
+		Auth   fakeSSOAuthenticator
+		Config config.SSO
+
+		WantLocationRE  string
+		WantSetCookieRE string
+	}{
+		{
+			Name: "redirectDefault",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{
+						"redirectUrl": []string{"http://example.com/continue"},
+					}.Encode(),
+				},
+			},
+			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http%3A%2F%2Fmatrix.example.com%2F_matrix%2Fv4%2Flogin%2Fsso%2Fcallback%3Fprovider%3D&nonce=.+&providerID=`,
+			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
+		},
+		{
+			Name: "redirectExplicitProvider",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{
+						"redirectUrl": []string{"http://example.com/continue"},
+					}.Encode(),
+				},
+			},
+			IDPID:           "someprovider",
+			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http.*%3Fprovider%3Dsomeprovider&nonce=.+&providerID=someprovider`,
+			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			got := SSORedirect(&tst.Req, tst.IDPID, &tst.Auth, &tst.Config)
+
+			if want := http.StatusFound; got.Code != want {
+				t.Errorf("SSORedirect Code: got %v, want %v", got.Code, want)
+			}
+
+			if m, err := regexp.MatchString(tst.WantLocationRE, got.Headers["Location"]); err != nil {
+				t.Fatalf("WantSetCookieRE failed: %v", err)
+			} else if !m {
+				t.Errorf("SSORedirect Location: got %q, want match %v", got.Headers["Location"], tst.WantLocationRE)
+			}
+
+			if m, err := regexp.MatchString(tst.WantSetCookieRE, got.Headers["Set-Cookie"]); err != nil {
+				t.Fatalf("WantSetCookieRE failed: %v", err)
+			} else if !m {
+				t.Errorf("SSORedirect Set-Cookie: got %q, want match %v", got.Headers["Set-Cookie"], tst.WantSetCookieRE)
+			}
+		})
+	}
+}
+
+func TestSSORedirectError(t *testing.T) {
+	tsts := []struct {
+		Name   string
+		Req    http.Request
+		IDPID  string
+		Auth   fakeSSOAuthenticator
+		Config config.SSO
+
+		WantCode int
+	}{
+		{
+			Name: "missingRedirectUrl",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path:     "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{}.Encode(),
+				},
+			},
+			WantCode: http.StatusBadRequest,
+		},
+		{
+			Name: "invalidRedirectUrl",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{
+						"redirectUrl": []string{"/continue"},
+					}.Encode(),
+				},
+			},
+			WantCode: http.StatusBadRequest,
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			got := SSORedirect(&tst.Req, tst.IDPID, &tst.Auth, &tst.Config)
+
+			if got.Code != tst.WantCode {
+				t.Errorf("SSORedirect Code: got %v, want %v", got.Code, tst.WantCode)
+			}
+		})
+	}
+}
+
+func TestSSOCallback(t *testing.T) {
+	nonce := "1234." + base64.RawURLEncoding.EncodeToString([]byte("http://matrix.example.com/continue"))
+
+	tsts := []struct {
+		Name    string
+		Req     http.Request
+		UserAPI fakeUserAPIForSSO
+		Auth    fakeSSOAuthenticator
+		Config  config.SSO
+
+		WantLocationRE  string
+		WantSetCookieRE string
+
+		WantAccountCreation    []*uapi.PerformAccountCreationRequest
+		WantLoginTokenCreation []*uapi.PerformLoginTokenCreationRequest
+		WantSaveSSOAssociation []*uapi.PerformSaveSSOAssociationRequest
+		WantQueryLocalpart     []*uapi.QueryLocalpartForSSORequest
+	}{
+		{
+			Name: "logIn",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: nonce,
+					}).String()},
+				},
+			},
+			UserAPI: fakeUserAPIForSSO{
+				localpart: "alocalpart",
+			},
+			Auth: fakeSSOAuthenticator{
+				callbackResult: sso.CallbackResult{
+					Identifier: &sso.UserIdentifier{
+						Namespace: "anamespace",
+						Issuer:    "anissuer",
+						Subject:   "asubject",
+					},
+				},
+			},
+			WantLocationRE:  `http://matrix.example.com/continue\?loginToken=atoken`,
+			WantSetCookieRE: "sso_nonce=;",
+
+			WantLoginTokenCreation: []*uapi.PerformLoginTokenCreationRequest{{Data: uapi.LoginTokenData{UserID: "@alocalpart:aservername"}}},
+			WantQueryLocalpart:     []*uapi.QueryLocalpartForSSORequest{{Namespace: "anamespace", Issuer: "anissuer", Subject: "asubject"}},
+		},
+		{
+			Name: "registerSuggested",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: nonce,
+					}).String()},
+				},
+			},
+			Auth: fakeSSOAuthenticator{
+				callbackResult: sso.CallbackResult{
+					Identifier: &sso.UserIdentifier{
+						Namespace: "anamespace",
+						Issuer:    "anissuer",
+						Subject:   "asubject",
+					},
+					SuggestedUserID: "asuggestedid",
+				},
+			},
+			WantLocationRE:  `http://matrix.example.com/continue\?loginToken=atoken`,
+			WantSetCookieRE: "sso_nonce=;",
+
+			WantAccountCreation:    []*uapi.PerformAccountCreationRequest{{Localpart: "asuggestedid", AccountType: uapi.AccountTypeUser, OnConflict: uapi.ConflictAbort}},
+			WantLoginTokenCreation: []*uapi.PerformLoginTokenCreationRequest{{Data: uapi.LoginTokenData{UserID: "@asuggestedid:aservername"}}},
+			WantSaveSSOAssociation: []*uapi.PerformSaveSSOAssociationRequest{{Namespace: "anamespace", Issuer: "anissuer", Subject: "asubject", Localpart: "asuggestedid"}},
+			WantQueryLocalpart:     []*uapi.QueryLocalpartForSSORequest{{Namespace: "anamespace", Issuer: "anissuer", Subject: "asubject"}},
+		},
+		{
+			Name: "registerNumeric",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: nonce,
+					}).String()},
+				},
+			},
+			Auth: fakeSSOAuthenticator{
+				callbackResult: sso.CallbackResult{
+					Identifier: &sso.UserIdentifier{
+						Namespace: "anamespace",
+						Issuer:    "anissuer",
+						Subject:   "asubject",
+					},
+				},
+			},
+			WantLocationRE:  `http://matrix.example.com/continue\?loginToken=atoken`,
+			WantSetCookieRE: "sso_nonce=;",
+
+			WantAccountCreation:    []*uapi.PerformAccountCreationRequest{{Localpart: "12345", AccountType: uapi.AccountTypeUser, OnConflict: uapi.ConflictAbort}},
+			WantLoginTokenCreation: []*uapi.PerformLoginTokenCreationRequest{{Data: uapi.LoginTokenData{UserID: "@12345:aservername"}}},
+			WantSaveSSOAssociation: []*uapi.PerformSaveSSOAssociationRequest{{Namespace: "anamespace", Issuer: "anissuer", Subject: "asubject", Localpart: "12345"}},
+			WantQueryLocalpart:     []*uapi.QueryLocalpartForSSORequest{{Namespace: "anamespace", Issuer: "anissuer", Subject: "asubject"}},
+		},
+		{
+			Name: "noIdentifierRedirectURL",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: nonce,
+					}).String()},
+				},
+			},
+			Auth: fakeSSOAuthenticator{
+				callbackResult: sso.CallbackResult{
+					RedirectURL: "http://auth.example.com/notdone",
+				},
+			},
+			WantLocationRE:  `http://auth.example.com/notdone`,
+			WantSetCookieRE: "^$",
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			got := SSOCallback(&tst.Req, &tst.UserAPI, &tst.Auth, &tst.Config, "aservername")
+
+			if want := http.StatusFound; got.Code != want {
+				t.Log(got)
+				t.Errorf("SSOCallback Code: got %v, want %v", got.Code, want)
+			}
+
+			if m, err := regexp.MatchString(tst.WantLocationRE, got.Headers["Location"]); err != nil {
+				t.Fatalf("WantSetCookieRE failed: %v", err)
+			} else if !m {
+				t.Errorf("SSOCallback Location: got %q, want match %v", got.Headers["Location"], tst.WantLocationRE)
+			}
+
+			if m, err := regexp.MatchString(tst.WantSetCookieRE, got.Headers["Set-Cookie"]); err != nil {
+				t.Fatalf("WantSetCookieRE failed: %v", err)
+			} else if !m {
+				t.Errorf("SSOCallback Set-Cookie: got %q, want match %v", got.Headers["Set-Cookie"], tst.WantSetCookieRE)
+			}
+
+			if diff := cmp.Diff(tst.WantAccountCreation, tst.UserAPI.gotAccountCreation); diff != "" {
+				t.Errorf("PerformAccountCreation: +got -want:\n%s", diff)
+			}
+			if diff := cmp.Diff(tst.WantLoginTokenCreation, tst.UserAPI.gotLoginTokenCreation); diff != "" {
+				t.Errorf("PerformLoginTokenCreation: +got -want:\n%s", diff)
+			}
+			if diff := cmp.Diff(tst.WantSaveSSOAssociation, tst.UserAPI.gotSaveSSOAssociation); diff != "" {
+				t.Errorf("PerformSaveSSOAssociation: +got -want:\n%s", diff)
+			}
+			if diff := cmp.Diff(tst.WantQueryLocalpart, tst.UserAPI.gotQueryLocalpart); diff != "" {
+				t.Errorf("QueryLocalpartForSSO: +got -want:\n%s", diff)
+			}
+		})
+	}
+}
+
+func TestSSOCallbackError(t *testing.T) {
+	nonce := "1234." + base64.RawURLEncoding.EncodeToString([]byte("http://matrix.example.com/continue"))
+	goodReq := http.Request{
+		Host: "matrix.example.com",
+		URL: &url.URL{
+			Path: "/_matrix/v4/login/sso/callback",
+			RawQuery: url.Values{
+				"provider": []string{"aprovider"},
+			}.Encode(),
+		},
+		Header: http.Header{
+			"Cookie": []string{(&http.Cookie{
+				Name:  "sso_nonce",
+				Value: nonce,
+			}).String()},
+		},
+	}
+	goodAuth := fakeSSOAuthenticator{
+		callbackResult: sso.CallbackResult{
+			Identifier: &sso.UserIdentifier{
+				Namespace: "anamespace",
+				Issuer:    "anissuer",
+				Subject:   "asubject",
+			},
+		},
+	}
+	errMocked := errors.New("mocked error")
+
+	tsts := []struct {
+		Name    string
+		Req     http.Request
+		UserAPI fakeUserAPIForSSO
+		Auth    fakeSSOAuthenticator
+		Config  config.SSO
+
+		WantCode int
+	}{
+		{
+			Name: "missingProvider",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: nonce,
+					}).String()},
+				},
+			},
+			WantCode: http.StatusBadRequest,
+		},
+		{
+			Name: "missingCookie",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+			},
+			WantCode: http.StatusBadRequest,
+		},
+		{
+			Name: "malformedCookie",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/callback",
+					RawQuery: url.Values{
+						"provider": []string{"aprovider"},
+					}.Encode(),
+				},
+				Header: http.Header{
+					"Cookie": []string{(&http.Cookie{
+						Name:  "sso_nonce",
+						Value: "badvalue",
+					}).String()},
+				},
+			},
+			WantCode: http.StatusBadRequest,
+		},
+		{
+			Name: "failedProcessCallback",
+			Req:  goodReq,
+			Auth: fakeSSOAuthenticator{
+				callbackErr: errMocked,
+			},
+			WantCode: http.StatusInternalServerError,
+		},
+		{
+			Name: "failedQueryLocalpartForSSO",
+			Req:  goodReq,
+			UserAPI: fakeUserAPIForSSO{
+				localpartErr: errMocked,
+			},
+			Auth:     goodAuth,
+			WantCode: http.StatusUnauthorized,
+		},
+		{
+			Name: "failedQueryNumericLocalpart",
+			Req:  goodReq,
+			UserAPI: fakeUserAPIForSSO{
+				numericLocalpartErr: errMocked,
+			},
+			Auth:     goodAuth,
+			WantCode: http.StatusInternalServerError,
+		},
+		{
+			Name: "failedAccountCreation",
+			Req:  goodReq,
+			UserAPI: fakeUserAPIForSSO{
+				accountCreationErr: errMocked,
+			},
+			Auth:     goodAuth,
+			WantCode: http.StatusInternalServerError,
+		},
+		{
+			Name: "failedSaveSSOAssociation",
+			Req:  goodReq,
+			UserAPI: fakeUserAPIForSSO{
+				saveSSOAssociationErr: errMocked,
+			},
+			Auth:     goodAuth,
+			WantCode: http.StatusInternalServerError,
+		},
+		{
+			Name: "failedPerformLoginTokenCreation",
+			Req:  goodReq,
+			UserAPI: fakeUserAPIForSSO{
+				localpart:             "alocalpart",
+				tokenTokenCreationErr: errMocked,
+			},
+			Auth:     goodAuth,
+			WantCode: http.StatusInternalServerError,
+		},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			got := SSOCallback(&tst.Req, &tst.UserAPI, &tst.Auth, &tst.Config, "aservername")
+
+			if got.Code != tst.WantCode {
+				t.Log(got)
+				t.Errorf("SSOCallback Code: got %v, want %v", got.Code, tst.WantCode)
+			}
+		})
+	}
+}
+
+type fakeSSOAuthenticator struct {
+	callbackResult sso.CallbackResult
+	callbackErr    error
+}
+
+func (auth *fakeSSOAuthenticator) AuthorizationURL(ctx context.Context, providerID, callbackURL, nonce string) (string, error) {
+	return (&url.URL{
+		Scheme: "http",
+		Host:   "auth.example.com",
+		Path:   "/authorize",
+	}).ResolveReference(&url.URL{
+		RawQuery: url.Values{
+			"callbackURL": []string{callbackURL},
+			"nonce":       []string{nonce},
+			"providerID":  []string{providerID},
+		}.Encode(),
+	}).String(), nil
+}
+
+func (auth *fakeSSOAuthenticator) ProcessCallback(ctx context.Context, providerID, callbackURL, nonce string, query url.Values) (*sso.CallbackResult, error) {
+	return &auth.callbackResult, auth.callbackErr
+}
+
+type fakeUserAPIForSSO struct {
+	userAPIForSSO
+
+	accountCreationErr    error
+	tokenTokenCreationErr error
+	saveSSOAssociationErr error
+	localpart             string
+	localpartErr          error
+	numericLocalpartErr   error
+
+	gotAccountCreation    []*uapi.PerformAccountCreationRequest
+	gotLoginTokenCreation []*uapi.PerformLoginTokenCreationRequest
+	gotSaveSSOAssociation []*uapi.PerformSaveSSOAssociationRequest
+	gotQueryLocalpart     []*uapi.QueryLocalpartForSSORequest
+}
+
+func (userAPI *fakeUserAPIForSSO) PerformAccountCreation(ctx context.Context, req *uapi.PerformAccountCreationRequest, res *uapi.PerformAccountCreationResponse) error {
+	userAPI.gotAccountCreation = append(userAPI.gotAccountCreation, req)
+	return userAPI.accountCreationErr
+}
+
+func (userAPI *fakeUserAPIForSSO) PerformLoginTokenCreation(ctx context.Context, req *uapi.PerformLoginTokenCreationRequest, res *uapi.PerformLoginTokenCreationResponse) error {
+	userAPI.gotLoginTokenCreation = append(userAPI.gotLoginTokenCreation, req)
+	res.Metadata = uapi.LoginTokenMetadata{
+		Token: "atoken",
+	}
+	return userAPI.tokenTokenCreationErr
+}
+
+func (userAPI *fakeUserAPIForSSO) PerformSaveSSOAssociation(ctx context.Context, req *uapi.PerformSaveSSOAssociationRequest, res *struct{}) error {
+	userAPI.gotSaveSSOAssociation = append(userAPI.gotSaveSSOAssociation, req)
+	return userAPI.saveSSOAssociationErr
+}
+
+func (userAPI *fakeUserAPIForSSO) QueryLocalpartForSSO(ctx context.Context, req *uapi.QueryLocalpartForSSORequest, res *uapi.QueryLocalpartForSSOResponse) error {
+	userAPI.gotQueryLocalpart = append(userAPI.gotQueryLocalpart, req)
+	res.Localpart = userAPI.localpart
+	return userAPI.localpartErr
+}
+
+func (userAPI *fakeUserAPIForSSO) QueryNumericLocalpart(ctx context.Context, res *uapi.QueryNumericLocalpartResponse) error {
+	res.ID = 12345
+	return userAPI.numericLocalpartErr
+}
diff --git a/setup/config/config_test.go b/setup/config/config_test.go
index cbc57ad18f..565e3c729a 100644
--- a/setup/config/config_test.go
+++ b/setup/config/config_test.go
@@ -62,7 +62,7 @@ global:
     local_part: "_server"
     display_name: "Server alerts"
     avatar: ""
-    room_name: "Server Alerts"	
+    room_name: "Server Alerts"
 app_service_api:
   internal_api:
     listen: http://localhost:7777
@@ -86,6 +86,22 @@ client_api:
   recaptcha_private_key: ""
   recaptcha_bypass_secret: ""
   recaptcha_siteverify_api: ""
+  login:
+    sso:
+      enabled: true
+      callback_url: http://example.com:8071/_matrix/v3/login/sso/callback
+      default_provider: github
+      providers:
+      - brand: github
+      - id: custom
+        name: "Custom Provider"
+        icon: "mxc://example.com/abc123"
+        type: oidc
+        oauth2:
+          client_id: aclientid
+          client_secret: aclientsecret
+        oidc:
+          discovery_url: http://auth.example.com/.well-known/openid-configuration
   turn:
     turn_user_lifetime: ""
     turn_uris: []
diff --git a/userapi/storage/storage_test.go b/userapi/storage/storage_test.go
index 5bee880d39..1c381ffeef 100644
--- a/userapi/storage/storage_test.go
+++ b/userapi/storage/storage_test.go
@@ -429,6 +429,41 @@ func Test_Pusher(t *testing.T) {
 	})
 }
 
+func Test_SSO(t *testing.T) {
+	alice := test.NewUser(t)
+	aliceLocalpart, _, err := gomatrixserverlib.SplitID('@', alice.ID)
+	assert.NoError(t, err)
+
+	test.WithAllDatabases(t, func(t *testing.T, dbType test.DBType) {
+		db, close := mustCreateDatabase(t, dbType)
+		defer close()
+
+		t.Log("Create SSO association")
+
+		ns := util.RandomString(8)
+		issuer := util.RandomString(8)
+		subject := util.RandomString(8)
+		err := db.SaveSSOAssociation(ctx, ns, issuer, subject, aliceLocalpart)
+		assert.NoError(t, err, "unable to save SSO association")
+
+		t.Log("Retrieve localpart for association")
+
+		gotLocalpart, err := db.GetLocalpartForSSO(ctx, ns, issuer, subject)
+		assert.Equal(t, aliceLocalpart, gotLocalpart)
+
+		t.Log("Remove SSO association")
+
+		err = db.RemoveSSOAssociation(ctx, ns, issuer, subject)
+		assert.NoError(t, err, "unexpected error")
+
+		t.Log("Verify the SSO association was removed")
+
+		gotLocalpart, err = db.GetLocalpartForSSO(ctx, ns, issuer, subject)
+		assert.NoError(t, err, "unable to get localpart for SSO subject")
+		assert.Equal(t, "", gotLocalpart)
+	})
+}
+
 func Test_ThreePID(t *testing.T) {
 	alice := test.NewUser(t)
 	aliceLocalpart, _, err := gomatrixserverlib.SplitID('@', alice.ID)

From 4362422a6d04aed831f65a14b4d957ad78aaaa1c Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 8 Jun 2022 09:24:08 +0200
Subject: [PATCH 25/35] Fix two lint errors.

---
 clientapi/auth/sso/sso.go       | 3 ++-
 userapi/storage/storage_test.go | 2 +-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/clientapi/auth/sso/sso.go b/clientapi/auth/sso/sso.go
index 90c613b37b..8847577cb9 100644
--- a/clientapi/auth/sso/sso.go
+++ b/clientapi/auth/sso/sso.go
@@ -26,7 +26,8 @@ import (
 )
 
 // maxHTTPTimeout is an upper bound on an HTTP request to an SSO
-// backend. The individual request context deadlines are also honored.
+// backend. The individual request context deadlines are also
+// honoured.
 const maxHTTPTimeout = 10 * time.Second
 
 // An Authenticator keeps a set of identity providers and dispatches
diff --git a/userapi/storage/storage_test.go b/userapi/storage/storage_test.go
index 1c381ffeef..a3b49bc11e 100644
--- a/userapi/storage/storage_test.go
+++ b/userapi/storage/storage_test.go
@@ -443,7 +443,7 @@ func Test_SSO(t *testing.T) {
 		ns := util.RandomString(8)
 		issuer := util.RandomString(8)
 		subject := util.RandomString(8)
-		err := db.SaveSSOAssociation(ctx, ns, issuer, subject, aliceLocalpart)
+		err = db.SaveSSOAssociation(ctx, ns, issuer, subject, aliceLocalpart)
 		assert.NoError(t, err, "unable to save SSO association")
 
 		t.Log("Retrieve localpart for association")

From dba1965c8b41010ad2caca1247c0af8d03e57306 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Wed, 8 Jun 2022 09:40:11 +0200
Subject: [PATCH 26/35] Fix two lint errors.

---
 clientapi/routing/sso.go        | 2 +-
 userapi/storage/storage_test.go | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 154b7e93d3..34accda1f6 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -224,7 +224,7 @@ func SSOCallback(
 		if localpart == "" {
 			util.GetLogger(ctx).WithField("ssoIdentifier", result.Identifier).Info("no suggested user ID from SSO provider")
 			var res uapi.QueryNumericLocalpartResponse
-			if err := userAPI.QueryNumericLocalpart(ctx, &res); err != nil {
+			if err = userAPI.QueryNumericLocalpart(ctx, &res); err != nil {
 				util.GetLogger(ctx).WithError(err).WithField("ssoIdentifier", result.Identifier).Error("failed to generate numeric localpart")
 				return jsonerror.InternalServerError()
 			}
diff --git a/userapi/storage/storage_test.go b/userapi/storage/storage_test.go
index 0308c847b0..c4ca0c2ff4 100644
--- a/userapi/storage/storage_test.go
+++ b/userapi/storage/storage_test.go
@@ -466,6 +466,7 @@ func Test_SSO(t *testing.T) {
 		t.Log("Retrieve localpart for association")
 
 		gotLocalpart, err := db.GetLocalpartForSSO(ctx, ns, issuer, subject)
+		assert.NoError(t, err, "unable to get localpart for SSO subject")
 		assert.Equal(t, aliceLocalpart, gotLocalpart)
 
 		t.Log("Remove SSO association")

From 6850db639552d762776df2ebbb96ac0c61399af2 Mon Sep 17 00:00:00 2001
From: Neil Alexander <neilalexander@users.noreply.github.com>
Date: Tue, 20 Sep 2022 13:15:26 +0100
Subject: [PATCH 27/35] Fix API wiring, linting

---
 clientapi/auth/sso/oauth2.go  |  6 +++---
 cmd/generate-config/main.go   | 40 +++++++++++++++++------------------
 userapi/inthttp/client_sso.go | 34 +++++++++++++----------------
 3 files changed, 38 insertions(+), 42 deletions(-)

diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index c36fa8c430..7e81027d5a 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -18,7 +18,7 @@ import (
 	"context"
 	"encoding/json"
 	"fmt"
-	"io/ioutil"
+	"io"
 	"net/http"
 	"net/url"
 	"strings"
@@ -168,7 +168,7 @@ func (p *oauth2IdentityProvider) getUserInfo(ctx context.Context, accessToken st
 	}
 	defer hresp.Body.Close() // nolint:errcheck
 
-	body, err := ioutil.ReadAll(hresp.Body)
+	body, err := io.ReadAll(hresp.Body)
 	if err != nil {
 		return "", "", "", err
 	}
@@ -205,7 +205,7 @@ func httpDo(ctx context.Context, hc *http.Client, req *http.Request) (*http.Resp
 		contentType := resp.Header.Get("Content-Type")
 		switch {
 		case strings.HasPrefix(contentType, "text/plain"):
-			bs, err := ioutil.ReadAll(resp.Body)
+			bs, err := io.ReadAll(resp.Body)
 			if err == nil {
 				if len(bs) > 80 {
 					bs = bs[:80]
diff --git a/cmd/generate-config/main.go b/cmd/generate-config/main.go
index be34b58f02..1a3f221eeb 100644
--- a/cmd/generate-config/main.go
+++ b/cmd/generate-config/main.go
@@ -65,26 +65,26 @@ func main() {
 		if *defaultsForCI {
 			cfg.AppServiceAPI.DisableTLSValidation = true
 			cfg.ClientAPI.RateLimiting.Enabled = false
-      cfg.ClientAPI.Login.SSO.Enabled = true
-		  cfg.ClientAPI.Login.SSO.Providers = []config.IdentityProvider{
-			  {
-				  Brand: "github",
-				  OAuth2: config.OAuth2{
-				  	ClientID:     "aclientid",
-				  	ClientSecret: "aclientsecret",
-				  },
-			  },
-			  {
-			  	Brand: "google",
-			  	OAuth2: config.OAuth2{
-			  		ClientID:     "aclientid",
-			  		ClientSecret: "aclientsecret",
-			  	},
-		  		OIDC: config.OIDC{
-		  			DiscoveryURL: "https://accounts.google.com/.well-known/openid-configuration",
-	  			},
-	  		},
-  		}
+			cfg.ClientAPI.Login.SSO.Enabled = true
+			cfg.ClientAPI.Login.SSO.Providers = []config.IdentityProvider{
+				{
+					Brand: "github",
+					OAuth2: config.OAuth2{
+						ClientID:     "aclientid",
+						ClientSecret: "aclientsecret",
+					},
+				},
+				{
+					Brand: "google",
+					OAuth2: config.OAuth2{
+						ClientID:     "aclientid",
+						ClientSecret: "aclientsecret",
+					},
+					OIDC: config.OIDC{
+						DiscoveryURL: "https://accounts.google.com/.well-known/openid-configuration",
+					},
+				},
+			}
 			cfg.FederationAPI.DisableTLSValidation = false
 			// don't hit matrix.org when running tests!!!
 			cfg.FederationAPI.KeyPerspectives = config.KeyPerspectives{}
diff --git a/userapi/inthttp/client_sso.go b/userapi/inthttp/client_sso.go
index e34130ed0e..4e1a24dfea 100644
--- a/userapi/inthttp/client_sso.go
+++ b/userapi/inthttp/client_sso.go
@@ -19,7 +19,6 @@ import (
 
 	"github.com/matrix-org/dendrite/internal/httputil"
 	"github.com/matrix-org/dendrite/userapi/api"
-	"github.com/opentracing/opentracing-go"
 )
 
 const (
@@ -28,26 +27,23 @@ const (
 	QueryLocalpartForSSOPath      = "/userapi/queryLocalpartForSSO"
 )
 
-func (h *httpUserInternalAPI) QueryLocalpartForSSO(ctx context.Context, req *api.QueryLocalpartForSSORequest, res *api.QueryLocalpartForSSOResponse) error {
-	span, ctx := opentracing.StartSpanFromContext(ctx, QueryLocalpartForSSOPath)
-	defer span.Finish()
-
-	apiURL := h.apiURL + QueryLocalpartForSSOPath
-	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+func (h *httpUserInternalAPI) QueryLocalpartForSSO(ctx context.Context, request *api.QueryLocalpartForSSORequest, response *api.QueryLocalpartForSSOResponse) error {
+	return httputil.CallInternalRPCAPI(
+		"QuerytLocalpartForSSO", h.apiURL+QueryLocalpartForSSOPath,
+		h.httpClient, ctx, request, response,
+	)
 }
 
-func (h *httpUserInternalAPI) PerformForgetSSO(ctx context.Context, req *api.PerformForgetSSORequest, res *struct{}) error {
-	span, ctx := opentracing.StartSpanFromContext(ctx, PerformForgetSSOPath)
-	defer span.Finish()
-
-	apiURL := h.apiURL + PerformForgetSSOPath
-	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+func (h *httpUserInternalAPI) PerformForgetSSO(ctx context.Context, request *api.PerformForgetSSORequest, response *struct{}) error {
+	return httputil.CallInternalRPCAPI(
+		"PerformForgetSSO", h.apiURL+PerformForgetSSOPath,
+		h.httpClient, ctx, request, response,
+	)
 }
 
-func (h *httpUserInternalAPI) PerformSaveSSOAssociation(ctx context.Context, req *api.PerformSaveSSOAssociationRequest, res *struct{}) error {
-	span, ctx := opentracing.StartSpanFromContext(ctx, PerformSaveSSOAssociationPath)
-	defer span.Finish()
-
-	apiURL := h.apiURL + PerformSaveSSOAssociationPath
-	return httputil.PostJSON(ctx, span, h.httpClient, apiURL, req, res)
+func (h *httpUserInternalAPI) PerformSaveSSOAssociation(ctx context.Context, request *api.PerformSaveSSOAssociationRequest, response *struct{}) error {
+	return httputil.CallInternalRPCAPI(
+		"PerformSaveSSOAssociation", h.apiURL+PerformSaveSSOAssociationPath,
+		h.httpClient, ctx, request, response,
+	)
 }

From b8ac83f8d54cecd4ff6b2d6fabdf6571472523b2 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 12:03:47 +0200
Subject: [PATCH 28/35] Moves the OAuth2 configuration under OIDC.

Easier to understand setting oidc.client_id when using OIDC.

This also adds a call to Verify in unit tests and fixes the current
test config issues.
---
 setup/config/config.go           | 28 ++++++++++++++++++++++++++++
 setup/config/config_clientapi.go | 28 ++++++++++++++++------------
 setup/config/config_test.go      | 25 +++++++++++++++++--------
 3 files changed, 61 insertions(+), 20 deletions(-)

diff --git a/setup/config/config.go b/setup/config/config.go
index 5a618d6716..f82ecb9705 100644
--- a/setup/config/config.go
+++ b/setup/config/config.go
@@ -371,6 +371,14 @@ func (errs *ConfigErrors) Add(str string) {
 	*errs = append(*errs, str)
 }
 
+// checkNotEmpty verifies the given value is empty in the configuration.
+// If it is, adds an error to the list.
+func checkEmpty(configErrs *ConfigErrors, key, value string) {
+	if value != "" {
+		configErrs.Add(fmt.Sprintf("expected empty key %q: %s", key, value))
+	}
+}
+
 // checkNotEmpty verifies the given value is not empty in the configuration.
 // If it is, adds an error to the list.
 func checkNotEmpty(configErrs *ConfigErrors, key, value string) {
@@ -415,6 +423,26 @@ func checkURL(configErrs *ConfigErrors, key, value string) {
 	}
 }
 
+// checkIconURL verifies that the parameter is a valid icon URL.
+func checkIconURL(configErrs *ConfigErrors, key, value string) {
+	if value == "" {
+		configErrs.Add(fmt.Sprintf("missing config key %q", key))
+		return
+	}
+	url, err := url.Parse(value)
+	if err != nil {
+		configErrs.Add(fmt.Sprintf("config key %q contains invalid URL (%s)", key, err.Error()))
+		return
+	}
+	switch url.Scheme {
+	case "http":
+	case "https":
+	case "mxc":
+	default:
+		configErrs.Add(fmt.Sprintf("invalid URL scheme for config key %q: %s", key, value))
+	}
+}
+
 // checkLogging verifies the parameters logging.* are valid.
 func (config *Dendrite) checkLogging(configErrs *ConfigErrors) {
 	for _, logrusHook := range config.Logging {
diff --git a/setup/config/config_clientapi.go b/setup/config/config_clientapi.go
index c814ac1b39..4cf000118b 100644
--- a/setup/config/config_clientapi.go
+++ b/setup/config/config_clientapi.go
@@ -162,6 +162,12 @@ func (sso *SSO) Verify(configErrs *ConfigErrors) {
 }
 
 type IdentityProvider struct {
+	// OAuth2 contains settings for IdPs based on OAuth2 (but not OpenID Connect).
+	OAuth2 OAuth2 `yaml:"oauth2"`
+
+	// OIDC contains settings for IdPs based on OpenID Connect.
+	OIDC OIDC `yaml:"oidc"`
+
 	// ID is the unique identifier of this IdP. If empty, the brand will be used.
 	ID string `yaml:"id"`
 
@@ -178,14 +184,8 @@ type IdentityProvider struct {
 	Icon string `yaml:"icon"`
 
 	// Type describes how this IdP is implemented. If this is empty, a default is chosen
-	// based on brand.
+	// based on brand or which subkeys exist.
 	Type IdentityProviderType `yaml:"type"`
-
-	// OAuth2 contains settings for IdPs based on OpenID Connect and OAuth2.
-	OAuth2 OAuth2 `yaml:"oauth2"`
-
-	// OIDC contains settings for IdPs based on OpenID Connect.
-	OIDC OIDC `yaml:"oidc"`
 }
 
 func (idp *IdentityProvider) WithDefaults() IdentityProvider {
@@ -216,6 +216,7 @@ type OAuth2 struct {
 }
 
 type OIDC struct {
+	OAuth2       `yaml:",inline"`
 	DiscoveryURL string `yaml:"discovery_url"`
 }
 
@@ -231,18 +232,21 @@ func (idp *IdentityProvider) verifyNormalized(configErrs *ConfigErrors) {
 		configErrs.Add(fmt.Sprintf("unrecognised brand in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Brand))
 	}
 	if idp.Icon != "" {
-		checkURL(configErrs, "client_api.sso.providers.icon", idp.Icon)
+		checkIconURL(configErrs, "client_api.sso.providers.icon", idp.Icon)
 	}
 
 	switch idp.Type {
 	case SSOTypeOIDC:
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OAuth2.ClientID)
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OAuth2.ClientSecret)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OIDC.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OIDC.ClientSecret)
 		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.discovery_url", idp.OIDC.DiscoveryURL)
 
+		checkEmpty(configErrs, "client_api.sso.providers.oauth2.client_id", idp.OAuth2.ClientID)
+		checkEmpty(configErrs, "client_api.sso.providers.oauth2.client_secret", idp.OAuth2.ClientSecret)
+
 	case SSOTypeGitHub:
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_id", idp.OAuth2.ClientID)
-		checkNotEmpty(configErrs, "client_api.sso.providers.oidc.client_secret", idp.OAuth2.ClientSecret)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oauth2.client_id", idp.OAuth2.ClientID)
+		checkNotEmpty(configErrs, "client_api.sso.providers.oauth2.client_secret", idp.OAuth2.ClientSecret)
 
 	default:
 		configErrs.Add(fmt.Sprintf("unrecognised type in identity provider %q for config key %q: %s", idp.ID, "client_api.sso.providers", idp.Type))
diff --git a/setup/config/config_test.go b/setup/config/config_test.go
index 30388b9573..e12d7b2120 100644
--- a/setup/config/config_test.go
+++ b/setup/config/config_test.go
@@ -22,7 +22,7 @@ import (
 )
 
 func TestLoadConfigRelative(t *testing.T) {
-	_, err := loadConfig("/my/config/dir", []byte(testConfig),
+	c, err := loadConfig("/my/config/dir", []byte(testConfig),
 		mockReadFile{
 			"/my/config/dir/matrix_key.pem": testKey,
 			"/my/config/dir/tls_cert.pem":   testCert,
@@ -32,6 +32,13 @@ func TestLoadConfigRelative(t *testing.T) {
 	if err != nil {
 		t.Error("failed to load config:", err)
 	}
+
+	var ss ConfigErrors
+	c.Verify(&ss, true)
+
+	for _, s := range ss {
+		t.Errorf("Verify: %s", s)
+	}
 }
 
 const testConfig = `
@@ -84,11 +91,11 @@ client_api:
     listen: http://[::]:8071
   registration_disabled: false
   registration_shared_secret: ""
-  enable_registration_captcha: false
-  recaptcha_public_key: ""
-  recaptcha_private_key: ""
+  enable_registration_captcha: true
+  recaptcha_public_key: a
+  recaptcha_private_key: b
   recaptcha_bypass_secret: ""
-  recaptcha_siteverify_api: ""
+  recaptcha_siteverify_api: c
   login:
     sso:
       enabled: true
@@ -96,15 +103,17 @@ client_api:
       default_provider: github
       providers:
       - brand: github
+        oauth2:
+          client_id: aclientid
+          client_secret: aclientsecret
       - id: custom
         name: "Custom Provider"
         icon: "mxc://example.com/abc123"
         type: oidc
-        oauth2:
-          client_id: aclientid
-          client_secret: aclientsecret
         oidc:
           discovery_url: http://auth.example.com/.well-known/openid-configuration
+          client_id: aclientid
+          client_secret: aclientsecret
   turn:
     turn_user_lifetime: ""
     turn_uris: []

From 7ceb276970f901519811c9f14fb26267238b34d6 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 12:13:42 +0200
Subject: [PATCH 29/35] Implement SSO default_provider.

---
 clientapi/routing/sso.go      |  7 +++++++
 clientapi/routing/sso_test.go | 29 ++++++++++++++++++++++++++++-
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 34accda1f6..3b809092e3 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -70,6 +70,13 @@ func SSORedirect(
 		}
 	}
 
+	if idpID == "" {
+		idpID = cfg.DefaultProviderID
+		if idpID == "" && len(cfg.Providers) > 0 {
+			idpID = cfg.Providers[0].ID
+		}
+	}
+
 	callbackURL, err := buildCallbackURLFromOther(cfg, req, "/login/sso/redirect")
 	if err != nil {
 		util.GetLogger(ctx).WithError(err).Error("Failed to build callback URL")
diff --git a/clientapi/routing/sso_test.go b/clientapi/routing/sso_test.go
index a26604b13b..c6ac3637ef 100644
--- a/clientapi/routing/sso_test.go
+++ b/clientapi/routing/sso_test.go
@@ -37,7 +37,30 @@ func TestSSORedirect(t *testing.T) {
 					}.Encode(),
 				},
 			},
-			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http%3A%2F%2Fmatrix.example.com%2F_matrix%2Fv4%2Flogin%2Fsso%2Fcallback%3Fprovider%3D&nonce=.+&providerID=`,
+			Config: config.SSO{
+				DefaultProviderID: "adefault",
+			},
+			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http%3A%2F%2Fmatrix.example.com%2F_matrix%2Fv4%2Flogin%2Fsso%2Fcallback%3Fprovider%3Dadefault&nonce=.+&providerID=adefault`,
+			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
+		},
+		{
+			Name: "redirectFirstProvider",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{
+						"redirectUrl": []string{"http://example.com/continue"},
+					}.Encode(),
+				},
+			},
+			Config: config.SSO{
+				Providers: []config.IdentityProvider{
+					{ID: "firstprovider"},
+					{ID: "secondprovider"},
+				},
+			},
+			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http%3A%2F%2Fmatrix.example.com%2F_matrix%2Fv4%2Flogin%2Fsso%2Fcallback%3Fprovider%3Dfirstprovider&nonce=.+&providerID=firstprovider`,
 			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
 		},
 		{
@@ -468,6 +491,10 @@ type fakeSSOAuthenticator struct {
 }
 
 func (auth *fakeSSOAuthenticator) AuthorizationURL(ctx context.Context, providerID, callbackURL, nonce string) (string, error) {
+	if providerID == "" {
+		return "", errors.New("empty providerID")
+	}
+
 	return (&url.URL{
 		Scheme: "http",
 		Host:   "auth.example.com",

From 1c17c200971c7e1840f14f7e8218cf4321e09538 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 12:15:07 +0200
Subject: [PATCH 30/35] Remove the check for claims_supported in OpenID Connect
 SSO.

This is speced as "not exhaustive" and "optional", which means it's
completely meaningless for standard claims.

* https://github.com/goauthentik/authentik/issues/3702
* https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
---
 clientapi/auth/sso/oidc.go | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index 7d00e457ff..ec8d2300fe 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -123,7 +123,6 @@ type oidcDiscovery struct {
 	TokenEndpoint         string   `json:"token_endpoint"`
 	UserinfoEndpoint      string   `json:"userinfo_endpoint"`
 	ScopesSupported       []string `json:"scopes_supported"`
-	ClaimsSupported       []string `json:"claims_supported"`
 }
 
 func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
@@ -167,14 +166,6 @@ func oidcDiscover(ctx context.Context, url string) (*oidcDiscovery, error) {
 		}
 	}
 
-	if disc.ClaimsSupported != nil {
-		for _, claim := range []string{"iss", "sub"} {
-			if !stringSliceContains(disc.ClaimsSupported, claim) {
-				return nil, fmt.Errorf("claim %q is not supported in %q", claim, url)
-			}
-		}
-	}
-
 	return &disc, nil
 }
 

From 808eb2279bf1ee4143f2ffed25d1f3fb8d7af506 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 12:19:32 +0200
Subject: [PATCH 31/35] Allow empty SSO redirectUrl paths.

E.g. "https://hydrogen.element.io"
---
 clientapi/routing/sso.go      |  2 +-
 clientapi/routing/sso_test.go | 15 +++++++++++++++
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/clientapi/routing/sso.go b/clientapi/routing/sso.go
index 3b809092e3..08b701ab08 100644
--- a/clientapi/routing/sso.go
+++ b/clientapi/routing/sso.go
@@ -63,7 +63,7 @@ func SSORedirect(
 			Code: http.StatusBadRequest,
 			JSON: jsonerror.InvalidArgumentValue("Invalid redirectURL: " + err.Error()),
 		}
-	} else if ru.Scheme == "" || ru.Host == "" || ru.Path == "" {
+	} else if ru.Scheme == "" || ru.Host == "" {
 		return util.JSONResponse{
 			Code: http.StatusBadRequest,
 			JSON: jsonerror.InvalidArgumentValue("Invalid redirectURL: " + redirectURL),
diff --git a/clientapi/routing/sso_test.go b/clientapi/routing/sso_test.go
index c6ac3637ef..dfcc9408ef 100644
--- a/clientapi/routing/sso_test.go
+++ b/clientapi/routing/sso_test.go
@@ -78,6 +78,21 @@ func TestSSORedirect(t *testing.T) {
 			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http.*%3Fprovider%3Dsomeprovider&nonce=.+&providerID=someprovider`,
 			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
 		},
+		{
+			Name: "redirectEmptyredirectPath",
+			Req: http.Request{
+				Host: "matrix.example.com",
+				URL: &url.URL{
+					Path: "/_matrix/v4/login/sso/redirect",
+					RawQuery: url.Values{
+						"redirectUrl": []string{"http://example.com"},
+					}.Encode(),
+				},
+			},
+			IDPID:           "someprovider",
+			WantLocationRE:  `http://auth.example.com/authorize\?callbackURL=http.*%3Fprovider%3Dsomeprovider&nonce=.+&providerID=someprovider`,
+			WantSetCookieRE: "sso_nonce=[^;].*Path=/_matrix/v4/login/sso",
+		},
 	}
 	for _, tst := range tsts {
 		t.Run(tst.Name, func(t *testing.T) {

From d67a34662ea3ef29a0197bce89a30af251494c5d Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 12:31:40 +0200
Subject: [PATCH 32/35] Attempt to disable a goconst lint check.

---
 setup/config/config.go | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/setup/config/config.go b/setup/config/config.go
index f82ecb9705..8fd82d1cd3 100644
--- a/setup/config/config.go
+++ b/setup/config/config.go
@@ -415,8 +415,8 @@ func checkURL(configErrs *ConfigErrors, key, value string) {
 		return
 	}
 	switch url.Scheme {
-	case "http":
-	case "https":
+	case "http": // nolint:goconst
+	case "https": // nolint:goconst
 	default:
 		configErrs.Add(fmt.Sprintf("config key %q URL should be http:// or https://", key))
 		return
@@ -435,8 +435,8 @@ func checkIconURL(configErrs *ConfigErrors, key, value string) {
 		return
 	}
 	switch url.Scheme {
-	case "http":
-	case "https":
+	case "http": // nolint:goconst
+	case "https": // nolint:goconst
 	case "mxc":
 	default:
 		configErrs.Add(fmt.Sprintf("invalid URL scheme for config key %q: %s", key, value))

From a773f24782a08a20cc5a2a77b61687114e03ef16 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 13:33:20 +0200
Subject: [PATCH 33/35] Fix generate-config for SSO config reorganization.

---
 cmd/generate-config/main.go | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cmd/generate-config/main.go b/cmd/generate-config/main.go
index 1a3f221eeb..e9e261cf8d 100644
--- a/cmd/generate-config/main.go
+++ b/cmd/generate-config/main.go
@@ -76,11 +76,11 @@ func main() {
 				},
 				{
 					Brand: "google",
-					OAuth2: config.OAuth2{
-						ClientID:     "aclientid",
-						ClientSecret: "aclientsecret",
-					},
 					OIDC: config.OIDC{
+						OAuth2: config.OAuth2{
+							ClientID:     "aclientid",
+							ClientSecret: "aclientsecret",
+						},
 						DiscoveryURL: "https://accounts.google.com/.well-known/openid-configuration",
 					},
 				},

From 098fb1257536ecd7f061d2fc182c98f5bec766b8 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Tue, 4 Oct 2022 13:52:47 +0200
Subject: [PATCH 34/35] Add a test for cmd/generate-config.

Veriying the generated configuration.

global.jetstream.addresses is required in polylith mode. Adding a
dummy value for CI.
---
 cmd/generate-config/main.go      | 45 ++++++++++++++++++++++----------
 cmd/generate-config/main_test.go | 33 +++++++++++++++++++++++
 2 files changed, 64 insertions(+), 14 deletions(-)
 create mode 100644 cmd/generate-config/main_test.go

diff --git a/cmd/generate-config/main.go b/cmd/generate-config/main.go
index e9e261cf8d..a8ba525334 100644
--- a/cmd/generate-config/main.go
+++ b/cmd/generate-config/main.go
@@ -3,6 +3,7 @@ package main
 import (
 	"flag"
 	"fmt"
+	"os"
 	"path/filepath"
 
 	"github.com/matrix-org/dendrite/setup/config"
@@ -12,13 +13,31 @@ import (
 )
 
 func main() {
-	defaultsForCI := flag.Bool("ci", false, "Populate the configuration with sane defaults for use in CI")
-	serverName := flag.String("server", "", "The domain name of the server if not 'localhost'")
-	dbURI := flag.String("db", "", "The DB URI to use for all components (PostgreSQL only)")
-	dirPath := flag.String("dir", "./", "The folder to use for paths (like SQLite databases, media storage)")
-	normalise := flag.String("normalise", "", "Normalise an existing configuration file by adding new/missing options and defaults")
-	polylith := flag.Bool("polylith", false, "Generate a config that makes sense for polylith deployments")
-	flag.Parse()
+	cfg, err := buildConfig(flag.CommandLine, os.Args[1:])
+	if err != nil {
+		fmt.Fprintln(os.Stderr, err)
+		os.Exit(1)
+	}
+
+	bs, err := yaml.Marshal(cfg)
+	if err != nil {
+		panic(err)
+	}
+
+	fmt.Println(string(bs))
+}
+
+func buildConfig(fs *flag.FlagSet, args []string) (*config.Dendrite, error) {
+	defaultsForCI := fs.Bool("ci", false, "Populate the configuration with sane defaults for use in CI")
+	serverName := fs.String("server", "", "The domain name of the server if not 'localhost'")
+	dbURI := fs.String("db", "", "The DB URI to use for all components (PostgreSQL only)")
+	dirPath := fs.String("dir", "./", "The folder to use for paths (like SQLite databases, media storage)")
+	normalise := fs.String("normalise", "", "Normalise an existing configuration file by adding new/missing options and defaults")
+	polylith := fs.Bool("polylith", false, "Generate a config that makes sense for polylith deployments")
+
+	if err := fs.Parse(args); err != nil {
+		return nil, err
+	}
 
 	var cfg *config.Dendrite
 	if *normalise == "" {
@@ -95,6 +114,9 @@ func main() {
 			cfg.UserAPI.BCryptCost = bcrypt.MinCost
 			cfg.Global.JetStream.InMemory = true
 			cfg.Global.JetStream.StoragePath = config.Path(*dirPath)
+			if *polylith {
+				cfg.Global.JetStream.Addresses = []string{"localhost"}
+			}
 			cfg.ClientAPI.RegistrationDisabled = false
 			cfg.ClientAPI.OpenRegistrationWithoutVerificationEnabled = true
 			cfg.ClientAPI.RegistrationSharedSecret = "complement"
@@ -106,14 +128,9 @@ func main() {
 	} else {
 		var err error
 		if cfg, err = config.Load(*normalise, !*polylith); err != nil {
-			panic(err)
+			return nil, err
 		}
 	}
 
-	j, err := yaml.Marshal(cfg)
-	if err != nil {
-		panic(err)
-	}
-
-	fmt.Println(string(j))
+	return cfg, nil
 }
diff --git a/cmd/generate-config/main_test.go b/cmd/generate-config/main_test.go
new file mode 100644
index 0000000000..df7aeca3c8
--- /dev/null
+++ b/cmd/generate-config/main_test.go
@@ -0,0 +1,33 @@
+package main
+
+import (
+	"flag"
+	"testing"
+
+	"github.com/matrix-org/dendrite/setup/config"
+)
+
+func TestBuildConfig(t *testing.T) {
+	tsts := []struct {
+		Name       string
+		Args       []string
+		IsMonolith bool
+	}{
+		{"ciMonolith", []string{"-ci"}, true},
+		{"ciPolylith", []string{"-ci", "-polylith"}, false},
+	}
+	for _, tst := range tsts {
+		t.Run(tst.Name, func(t *testing.T) {
+			cfg, err := buildConfig(flag.NewFlagSet("main_test", flag.ContinueOnError), tst.Args)
+			if err != nil {
+				t.Fatalf("buildConfig failed: %v", err)
+			}
+
+			var ss config.ConfigErrors
+			cfg.Verify(&ss, tst.IsMonolith)
+			for _, s := range ss {
+				t.Errorf("Verify: %s", s)
+			}
+		})
+	}
+}

From 59a327da19994085d2dac031136862c7432b5666 Mon Sep 17 00:00:00 2001
From: Tommie Gannert <tommie@gannert.se>
Date: Thu, 10 Nov 2022 17:29:46 +0100
Subject: [PATCH 35/35] Fix clientapi for the OAuth2 OIDC refactoring in
 b8ac83f.

---
 clientapi/auth/sso/github.go      |  5 +++--
 clientapi/auth/sso/oauth2.go      | 11 ++++++-----
 clientapi/auth/sso/oauth2_test.go |  4 ++++
 clientapi/auth/sso/oidc.go        |  5 +++--
 clientapi/auth/sso/oidc_test.go   | 12 ++++++------
 clientapi/auth/sso/sso_test.go    |  6 +++---
 6 files changed, 25 insertions(+), 18 deletions(-)

diff --git a/clientapi/auth/sso/github.go b/clientapi/auth/sso/github.go
index 70f1a95e08..8a4cffab1b 100644
--- a/clientapi/auth/sso/github.go
+++ b/clientapi/auth/sso/github.go
@@ -22,8 +22,9 @@ import (
 
 func newGitHubIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) identityProvider {
 	return &oauth2IdentityProvider{
-		cfg: cfg,
-		hc:  hc,
+		cfg:       cfg,
+		oauth2Cfg: &cfg.OAuth2,
+		hc:        hc,
 
 		authorizationURL: "https://github.com/login/oauth/authorize",
 		accessTokenURL:   "https://github.com/login/oauth/access_token",
diff --git a/clientapi/auth/sso/oauth2.go b/clientapi/auth/sso/oauth2.go
index 7e81027d5a..f8101ef8aa 100644
--- a/clientapi/auth/sso/oauth2.go
+++ b/clientapi/auth/sso/oauth2.go
@@ -31,8 +31,9 @@ import (
 )
 
 type oauth2IdentityProvider struct {
-	cfg *config.IdentityProvider
-	hc  *http.Client
+	cfg       *config.IdentityProvider
+	oauth2Cfg *config.OAuth2
+	hc        *http.Client
 
 	authorizationURL string
 	accessTokenURL   string
@@ -48,7 +49,7 @@ type oauth2IdentityProvider struct {
 
 func (p *oauth2IdentityProvider) AuthorizationURL(ctx context.Context, callbackURL, nonce string) (string, error) {
 	u, err := resolveURL(p.authorizationURL, url.Values{
-		"client_id":     []string{p.cfg.OAuth2.ClientID},
+		"client_id":     []string{p.oauth2Cfg.ClientID},
 		"response_type": []string{"code"},
 		"redirect_uri":  []string{callbackURL},
 		"scope":         []string{strings.Join(p.scopes, " ")},
@@ -121,8 +122,8 @@ func (p *oauth2IdentityProvider) getAccessToken(ctx context.Context, callbackURL
 		"grant_type":    []string{"authorization_code"},
 		"code":          []string{code},
 		"redirect_uri":  []string{callbackURL},
-		"client_id":     []string{p.cfg.OAuth2.ClientID},
-		"client_secret": []string{p.cfg.OAuth2.ClientSecret},
+		"client_id":     []string{p.oauth2Cfg.ClientID},
+		"client_secret": []string{p.oauth2Cfg.ClientSecret},
 	}
 	hreq, err := http.NewRequestWithContext(ctx, http.MethodPost, p.accessTokenURL, strings.NewReader(body.Encode()))
 	if err != nil {
diff --git a/clientapi/auth/sso/oauth2_test.go b/clientapi/auth/sso/oauth2_test.go
index f541a52368..43b040f5ce 100644
--- a/clientapi/auth/sso/oauth2_test.go
+++ b/clientapi/auth/sso/oauth2_test.go
@@ -25,6 +25,7 @@ func TestOAuth2IdentityProviderAuthorizationURL(t *testing.T) {
 
 		authorizationURL: "https://oauth2.example.com/authorize",
 	}
+	idp.oauth2Cfg = &idp.cfg.OAuth2
 
 	got, err := idp.AuthorizationURL(ctx, "https://matrix.example.com/continue", "anonce")
 	if err != nil {
@@ -98,6 +99,7 @@ func TestOAuth2IdentityProviderProcessCallback(t *testing.T) {
 				displayNamePath:     "name",
 				suggestedUserIDPath: "preferred_user",
 			}
+			idp.oauth2Cfg = &idp.cfg.OAuth2
 
 			got, err := idp.ProcessCallback(ctx, callbackURL, "anonce", tst.Query)
 			if err != nil {
@@ -145,6 +147,7 @@ func TestOAuth2IdentityProviderGetAccessToken(t *testing.T) {
 
 		accessTokenURL: s.URL + "/token",
 	}
+	idp.oauth2Cfg = &idp.cfg.OAuth2
 
 	got, err := idp.getAccessToken(ctx, callbackURL, "acode")
 	if err != nil {
@@ -198,6 +201,7 @@ func TestOAuth2IdentityProviderGetUserInfo(t *testing.T) {
 		displayNamePath:     "name",
 		suggestedUserIDPath: "preferred_user",
 	}
+	idp.oauth2Cfg = &idp.cfg.OAuth2
 
 	gotSub, gotName, gotSuggestedUser, err := idp.getUserInfo(ctx, "atoken")
 	if err != nil {
diff --git a/clientapi/auth/sso/oidc.go b/clientapi/auth/sso/oidc.go
index ec8d2300fe..8cc691582b 100644
--- a/clientapi/auth/sso/oidc.go
+++ b/clientapi/auth/sso/oidc.go
@@ -50,8 +50,9 @@ type oidcIdentityProvider struct {
 func newOIDCIdentityProvider(cfg *config.IdentityProvider, hc *http.Client) *oidcIdentityProvider {
 	return &oidcIdentityProvider{
 		oauth2IdentityProvider: &oauth2IdentityProvider{
-			cfg: cfg,
-			hc:  hc,
+			cfg:       cfg,
+			oauth2Cfg: &cfg.OIDC.OAuth2,
+			hc:        hc,
 
 			scopes:              []string{"openid", "profile", "email"},
 			responseMimeType:    "application/json",
diff --git a/clientapi/auth/sso/oidc_test.go b/clientapi/auth/sso/oidc_test.go
index 21205e80cc..65e363ec37 100644
--- a/clientapi/auth/sso/oidc_test.go
+++ b/clientapi/auth/sso/oidc_test.go
@@ -26,10 +26,10 @@ func TestOIDCIdentityProviderAuthorizationURL(t *testing.T) {
 	defer s.Close()
 
 	idp := newOIDCIdentityProvider(&config.IdentityProvider{
-		OAuth2: config.OAuth2{
-			ClientID: "aclientid",
-		},
 		OIDC: config.OIDC{
+			OAuth2: config.OAuth2{
+				ClientID: "aclientid",
+			},
 			DiscoveryURL: s.URL + "/discovery",
 		},
 	}, s.Client())
@@ -97,10 +97,10 @@ func TestOIDCIdentityProviderProcessCallback(t *testing.T) {
 
 			sURL = s.URL
 			idp := newOIDCIdentityProvider(&config.IdentityProvider{
-				OAuth2: config.OAuth2{
-					ClientID: "aclientid",
-				},
 				OIDC: config.OIDC{
+					OAuth2: config.OAuth2{
+						ClientID: "aclientid",
+					},
 					DiscoveryURL: sURL + "/discovery",
 				},
 			}, s.Client())
diff --git a/clientapi/auth/sso/sso_test.go b/clientapi/auth/sso/sso_test.go
index 663e077213..c385faaf2d 100644
--- a/clientapi/auth/sso/sso_test.go
+++ b/clientapi/auth/sso/sso_test.go
@@ -20,10 +20,10 @@ func TestNewAuthenticator(t *testing.T) {
 			},
 			{
 				Type: config.SSOTypeOIDC,
-				OAuth2: config.OAuth2{
-					ClientID: "aclientid",
-				},
 				OIDC: config.OIDC{
+					OAuth2: config.OAuth2{
+						ClientID: "aclientid",
+					},
 					DiscoveryURL: "http://oidc.example.com/discovery",
 				},
 			},
